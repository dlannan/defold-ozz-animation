// This file is autogenerated. Any modification might be lost.

// Including raw_animation.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_animation.h"
#include "ozz/animation/runtime/skeleton.h"

namespace ozz {
namespace animation {
namespace offline {

RawAnimation::RawAnimation() : duration(1.f) {}

namespace {

// Implements key frames' time range and ordering checks.
// See AnimationBuilder::Create for more details.
template <typename _Key>
static bool ValidateTrack(const typename ozz::vector<_Key>& _track,
                          float _duration) {
  float previous_time = -1.f;
  for (size_t k = 0; k < _track.size(); ++k) {
    const float frame_time = _track[k].time;
    // Tests frame's time is in range [0:duration].
    if (frame_time < 0.f || frame_time > _duration) {
      return false;
    }
    // Tests that frames are sorted.
    if (frame_time <= previous_time) {
      return false;
    }
    previous_time = frame_time;
  }
  return true;  // Validated.
}
}  // namespace
bool RawAnimation::JointTrack::Validate(float _duration) const {
  return ValidateTrack<TranslationKey>(translations, _duration) &&
         ValidateTrack<RotationKey>(rotations, _duration) &&
         ValidateTrack<ScaleKey>(scales, _duration);
}

bool RawAnimation::Validate() const {
  if (duration <= 0.f) {  // Tests duration is valid.
    return false;
  }
  if (tracks.size() > Skeleton::kMaxJoints) {  // Tests number of tracks.
    return false;
  }
  // Ensures that all key frames' time are valid, ie: in a strict ascending
  // order and within range [0:duration].
  bool valid = true;
  for (size_t i = 0; valid && i < tracks.size(); ++i) {
    valid = tracks[i].Validate(duration);
  }
  return valid;  // *this is valid.
}

size_t RawAnimation::size() const {
  size_t size = sizeof(*this);

  // Accumulates keyframes size.
  const size_t tracks_count = tracks.size();
  for (size_t i = 0; i < tracks_count; ++i) {
    size += tracks[i].translations.size() * sizeof(TranslationKey);
    size += tracks[i].rotations.size() * sizeof(RotationKey);
    size += tracks[i].scales.size() * sizeof(ScaleKey);
  }

  // Accumulates tracks.
  size += tracks_count * sizeof(JointTrack);
  size += name.size();

  return size;
}

}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_animation_archive.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_animation.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/maths/math_archive.h"

#include "ozz/base/containers/string_archive.h"
#include "ozz/base/containers/vector_archive.h"
#include "ozz/base/log.h"

namespace ozz {
namespace io {

void Extern<animation::offline::RawAnimation>::Save(
    OArchive& _archive, const animation::offline::RawAnimation* _animations,
    size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawAnimation& animation = _animations[i];
    _archive << animation.duration;
    _archive << animation.tracks;
    _archive << animation.name;
  }
}

void Extern<animation::offline::RawAnimation>::Load(
    IArchive& _archive, animation::offline::RawAnimation* _animations,
    size_t _count, uint32_t _version) {
  if (_version < 3) {
    log::Err() << "Unsupported RawAnimation version " << _version << "."
               << std::endl;
    return;
  }
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawAnimation& animation = _animations[i];
    _archive >> animation.duration;
    _archive >> animation.tracks;
    _archive >> animation.name;
  }
}

// RawAnimation::*Keys' version can be declared locally as it will be saved from
// this cpp file only.

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::JointTrack)

template <>
struct Extern<animation::offline::RawAnimation::JointTrack> {
  static void Save(OArchive& _archive,
                   const animation::offline::RawAnimation::JointTrack* _tracks,
                   size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::offline::RawAnimation::JointTrack& track = _tracks[i];
      _archive << track.translations;
      _archive << track.rotations;
      _archive << track.scales;
    }
  }
  static void Load(IArchive& _archive,
                   animation::offline::RawAnimation::JointTrack* _tracks,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::offline::RawAnimation::JointTrack& track = _tracks[i];
      _archive >> track.translations;
      _archive >> track.rotations;
      _archive >> track.scales;
    }
  }
};

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::TranslationKey)

template <>
struct Extern<animation::offline::RawAnimation::TranslationKey> {
  static void Save(
      OArchive& _archive,
      const animation::offline::RawAnimation::TranslationKey* _keys,
      size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::offline::RawAnimation::TranslationKey& key = _keys[i];
      _archive << key.time;
      _archive << key.value;
    }
  }
  static void Load(IArchive& _archive,
                   animation::offline::RawAnimation::TranslationKey* _keys,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::offline::RawAnimation::TranslationKey& key = _keys[i];
      _archive >> key.time;
      _archive >> key.value;
    }
  }
};

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::RotationKey)

template <>
struct Extern<animation::offline::RawAnimation::RotationKey> {
  static void Save(OArchive& _archive,
                   const animation::offline::RawAnimation::RotationKey* _keys,
                   size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::offline::RawAnimation::RotationKey& key = _keys[i];
      _archive << key.time;
      _archive << key.value;
    }
  }
  static void Load(IArchive& _archive,
                   animation::offline::RawAnimation::RotationKey* _keys,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::offline::RawAnimation::RotationKey& key = _keys[i];
      _archive >> key.time;
      _archive >> key.value;
    }
  }
};

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::ScaleKey)

template <>
struct Extern<animation::offline::RawAnimation::ScaleKey> {
  static void Save(OArchive& _archive,
                   const animation::offline::RawAnimation::ScaleKey* _keys,
                   size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::offline::RawAnimation::ScaleKey& key = _keys[i];
      _archive << key.time;
      _archive << key.value;
    }
  }
  static void Load(IArchive& _archive,
                   animation::offline::RawAnimation::ScaleKey* _keys,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::offline::RawAnimation::ScaleKey& key = _keys[i];
      _archive >> key.time;
      _archive >> key.value;
    }
  }
};
}  // namespace io
}  // namespace ozz

// Including raw_animation_utils.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_animation_utils.h"

#include <algorithm>
#include <limits>

namespace ozz {
namespace animation {
namespace offline {

// Translation interpolation method.
// This must be the same Lerp as the one used by the sampling job.
math::Float3 LerpTranslation(const math::Float3& _a, const math::Float3& _b,
                             float _alpha) {
  return math::Lerp(_a, _b, _alpha);
}

// Rotation interpolation method.
// This must be the same Lerp as the one used by the sampling job.
// The goal is to take the shortest path between _a and _b. This code replicates
// this behavior that is actually not done at runtime, but when building the
// animation.
math::Quaternion LerpRotation(const math::Quaternion& _a,
                              const math::Quaternion& _b, float _alpha) {
  // Finds the shortest path. This is done by the AnimationBuilder for runtime
  // animations.
  const float dot = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z + _a.w * _b.w;
  return math::NLerp(_a, dot < 0.f ? -_b : _b, _alpha);  // _b an -_b are the
                                                         // same rotation.
}

// Scale interpolation method.
// This must be the same Lerp as the one used by the sampling job.
math::Float3 LerpScale(const math::Float3& _a, const math::Float3& _b,
                       float _alpha) {
  return math::Lerp(_a, _b, _alpha);
}

namespace {

// The next functions are used to sample a RawAnimation. This feature is not
// part of ozz sdk, as RawAnimation is a intermediate format used to build the
// runtime animation.

// Less comparator, used by search algorithm to walk through track sorted
// keyframes
template <typename _Key>
bool Less(const _Key& _left, const _Key& _right) {
  return _left.time < _right.time;
}

// Samples a component (translation, rotation or scale) of a track.
template <typename _Track, typename _Lerp>
typename _Track::value_type::Value SampleComponent(const _Track& _track,
                                                   const _Lerp& _lerp,
                                                   float _time) {
  if (_track.size() == 0) {
    // Return identity if there's no key for this track.
    return _Track::value_type::identity();
  } else if (_time <= _track.front().time) {
    // Returns the first keyframe if _time is before the first keyframe.
    return _track.front().value;
  } else if (_time >= _track.back().time) {
    // Returns the last keyframe if _time is before the last keyframe.
    return _track.back().value;
  } else {
    // Needs to interpolate the 2 keyframes before and after _time.
    assert(_track.size() >= 2);
    // First find the 2 keys.
    const typename _Track::value_type cmp = {_time,
                                             _Track::value_type::identity()};
    typename _Track::const_pointer it =
        std::lower_bound(array_begin(_track), array_end(_track), cmp,
                         Less<typename _Track::value_type>);
    assert(it > array_begin(_track) && it < array_end(_track));

    // Then interpolate them at t = _time.
    const typename _Track::const_reference right = it[0];
    const typename _Track::const_reference left = it[-1];
    const float alpha = (_time - left.time) / (right.time - left.time);
    return _lerp(left.value, right.value, alpha);
  }
}

void SampleTrack_NoValidate(const RawAnimation::JointTrack& _track, float _time,
                            ozz::math::Transform* _transform) {
  _transform->translation =
      SampleComponent(_track.translations, LerpTranslation, _time);
  _transform->rotation = SampleComponent(_track.rotations, LerpRotation, _time);
  _transform->scale = SampleComponent(_track.scales, LerpScale, _time);
}
}  // namespace

bool SampleTrack(const RawAnimation::JointTrack& _track, float _time,
                 ozz::math::Transform* _transform) {
  if (!_track.Validate(std::numeric_limits<float>::infinity())) {
    return false;
  }

  SampleTrack_NoValidate(_track, _time, _transform);
  return true;
}

bool SampleAnimation(const RawAnimation& _animation, float _time,
                     const span<ozz::math::Transform>& _transforms) {
  if (!_animation.Validate()) {
    return false;
  }
  if (_animation.tracks.size() > _transforms.size()) {
    return false;
  }

  for (size_t i = 0; i < _animation.tracks.size(); ++i) {
    SampleTrack_NoValidate(_animation.tracks[i], _time,
                           _transforms.begin() + i);
  }
  return true;
}

namespace {
template <typename _Track, typename _Times>
inline void CopyKeyTimes(const _Track& _track, _Times* _key_times) {
  for (size_t i = 0; i < _track.size(); ++i) {
    _key_times->push_back(_track[i].time);
  }
}
}  // namespace

ozz::vector<float> ExtractTimePoints(const RawAnimation& _animation) {
  ozz::vector<float> times;

  if (!_animation.Validate()) {
    return times;
  }

  // Gets union of all possible keyframe times.
  for (int i = 0; i < _animation.num_tracks(); ++i) {
    const RawAnimation::JointTrack& track = _animation.tracks[i];
    CopyKeyTimes(track.translations, &times);
    CopyKeyTimes(track.rotations, &times);
    CopyKeyTimes(track.scales, &times);

    std::sort(times.begin(), times.end());
    times.erase(std::unique(times.begin(), times.end()), times.end());
  }

  return times;
}

FixedRateSamplingTime::FixedRateSamplingTime(float _duration, float _frequency)
    : duration_(_duration),
      period_(1.f / _frequency),
      num_keys_(static_cast<size_t>(std::ceil(1.f + _duration * _frequency))) {}

}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including animation_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/animation_builder.h"

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstring>
#include <limits>
#include <numeric>

#include "ozz/animation/offline/raw_animation.h"
#include "ozz/animation/offline/raw_animation_utils.h"
#include "ozz/animation/runtime/animation.h"
#include "ozz/base/containers/vector.h"
#include "ozz/base/encode/group_varint.h"
#include "ozz/base/maths/simd_math.h"
#include "ozz/base/memory/allocator.h"

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#include "ozz/animation/runtime/export.h"
#include "ozz/base/platform.h"

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {
namespace internal {

// Offset to previous keyframes are stored on uint16_t.
enum Constants { kMaxPreviousOffset = (1 << 16) - 1 };

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time ratio and it's track index. This is
// required as key frames are not sorted per track, but sorted by ratio to favor
// cache coherency. Key frame values are compressed, according on their type.
// Decompression is efficient because it's done on SoA data and cached during
// sampling.

// Defines the float3 key frame type, used for translations and scales.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct OZZ_ANIMATION_DLL Float3Key {
  uint16_t values[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [-1:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
struct QuaternionKey {
  // 2b for the largest component index of the quaternion.
  // 1b for the sign of the largest component. 1 for negative.
  // 15b for each component
  uint16_t values[3];

  // Quantization scale, depends on number of bits.
  static constexpr int kBits = 15;
  static constexpr int kiScale = (1 << kBits) - 1;
  static constexpr float kfScale = 1.f * kiScale;
};

// Endianness independent load and store
inline void pack(int _largest, int _sign, const int _cpnt[3],
                 QuaternionKey* _key) {
  const uint64_t packed =
      (_largest & 0x3) | ((_sign & 0x1) << 2) | (_cpnt[0] & 0x7fff) << 3 |
      uint64_t(_cpnt[1] & 0x7fff) << 18 | (uint64_t(_cpnt[2]) & 0x7fff) << 33;
  _key->values[0] = packed & 0xffff;
  _key->values[1] = (packed >> 16) & 0xffff;
  _key->values[2] = (packed >> 32) & 0xffff;
}

inline void unpack(const QuaternionKey& _key, int& _biggest, int& _sign,
                   int _cpnt[3]) {
  const uint32_t packed = uint32_t(_key.values[0]) >> 3 |
                          uint32_t(_key.values[1]) << 13 |
                          uint32_t(_key.values[2]) << 29;
  _biggest = _key.values[0] & 0x3;
  _sign = (_key.values[0] >> 2) & 0x1;
  _cpnt[0] = packed & 0x7fff;
  _cpnt[1] = (packed >> 15) & 0x7fff;
  _cpnt[2] = _key.values[2] >> 1;
}

}  // namespace internal
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {
namespace offline {
namespace {

template <typename _Key>
struct SortingKey {
  uint16_t track;
  float prev_key_time;
  _Key key;
};

typedef SortingKey<RawAnimation::TranslationKey> SortingTranslationKey;
typedef SortingKey<RawAnimation::RotationKey> SortingQuaternionKey;
typedef SortingKey<RawAnimation::ScaleKey> SortingScaleKey;

// Keyframe sorting. Stores first by time and then track number.
template <typename _Key>
bool SortingKeyLess(const _Key& _left, const _Key& _right) {
  const float time_diff = _left.prev_key_time - _right.prev_key_time;
  return time_diff < 0.f || (time_diff == 0.f && _left.track < _right.track);
}

template <typename _SrcKey, typename _DestTrack>
void PushBackIdentityKey(uint16_t _track, float _time, _DestTrack* _dest) {
  typedef typename _DestTrack::value_type DestKey;
  float prev_time = -1.f;
  if (!_dest->empty() && _dest->back().track == _track) {
    prev_time = _dest->back().key.time;
  }
  const DestKey key = {_track, prev_time, {_time, _SrcKey::identity()}};
  _dest->push_back(key);
}

// Copies a track from a RawAnimation to an Animation.
// Also fixes up the front (t = 0) and back keys (t = duration).
template <typename _SrcTrack, typename _DestTrack>
void CopyRaw(const _SrcTrack& _src, uint16_t _track, float _duration,
             _DestTrack* _dest) {
  typedef typename _SrcTrack::value_type SrcKey;
  typedef typename _DestTrack::value_type DestKey;

  if (_src.size() == 0) {  // Adds 2 new keys.
    PushBackIdentityKey<SrcKey, _DestTrack>(_track, 0.f, _dest);
    PushBackIdentityKey<SrcKey, _DestTrack>(_track, _duration, _dest);
  } else if (_src.size() == 1) {  // Adds 1 new key.
    const SrcKey& raw_key = _src.front();
    assert(raw_key.time >= 0 && raw_key.time <= _duration);
    const DestKey first = {_track, -1.f, {0.f, raw_key.value}};
    _dest->push_back(first);
    const DestKey last = {_track, 0.f, {_duration, raw_key.value}};
    _dest->push_back(last);
  } else {  // Copies all keys, and fixes up first and last keys.
    float prev_time = -1.f;
    if (_src.front().time != 0.f) {  // Needs a key at t = 0.f.
      const DestKey first = {_track, prev_time, {0.f, _src.front().value}};
      _dest->push_back(first);
      prev_time = 0.f;
    }
    for (size_t k = 0; k < _src.size(); ++k) {  // Copies all keys.
      const SrcKey& raw_key = _src[k];
      assert(raw_key.time >= 0 && raw_key.time <= _duration);
      const DestKey key = {_track, prev_time, {raw_key.time, raw_key.value}};
      _dest->push_back(key);
      prev_time = raw_key.time;
    }
    if (_src.back().time - _duration != 0.f) {  // Needs a key at t = _duration.
      const DestKey last = {_track, prev_time, {_duration, _src.back().value}};
      _dest->push_back(last);
    }
  }
  assert(_dest->front().key.time == 0.f &&
         _dest->back().key.time - _duration == 0.f);
}

template <typename _SortingKey, class _Lerp, class _Compare>
void Sort(ozz::vector<_SortingKey>& _src, size_t _num_tracks,
          const _Lerp& _lerp, const _Compare& _comp) {
  // Sorts whole vector
  std::sort(_src.begin(), _src.end(), _comp);

  // Will store last 2 keys (last and penultimate) for a track.
  ozz::vector<std::pair<int, int>> previouses(_num_tracks);
  for (bool loop = true; loop;) {
    loop = false;  // Will be set to true again if vector was changed.

    // Reset all previouses to default.
    const std::pair<int, int> default_previous{-1, -1};
    std::fill(previouses.begin(), previouses.end(), default_previous);

    // Loop through all keys.
    for (size_t i = 0; i < _src.size(); ++i) {
      const uint16_t track = _src[i].track;
      auto& previous = previouses[track];

      // Inject key if distance from previous one is too big to be stored in
      // runtime data structure (aka index to previous frame bigger than
      // kMaxPreviousOffset)
      if (previous.first != -1 &&
          i - previous.first > ozz::animation::internal::kMaxPreviousOffset) {
        assert(previous.second != -1 &&
               "Not possible not to have a valid penultimate key.");
        // Copy as originals are going to be (re)moved.
        _SortingKey last = _src[previous.first];
        const _SortingKey penultimate = _src[previous.second];

        // Prepares new key to insert.
        const _SortingKey insert = {
            track,
            penultimate.key.time,
            {(penultimate.key.time + last.key.time) * .5f,
             _lerp(penultimate.key.value, last.key.value, .5f)}};

        // Removes previous.first key that is changing and needs to be resorted.
        _src.erase(_src.begin() + previous.first);

        // Pushes the new key....
        _src.push_back(insert);

        // ... and the modified one, in the correct order (for the merge).
        last.prev_key_time = insert.key.time;
        _src.push_back(last);

        // Re-sorts vector in place. Last 2 keys where added. Nothing has
        // changed before previous.second.
        std::inplace_merge(_src.begin() + previous.second, _src.end() - 2,
                           _src.end(), _comp);

        // Restart as things have changed behind insertion point and previouses
        // need to be rebuilt.
        loop = true;
        break;
      }

      // Updates previouses
      previous.second = previous.first;
      previous.first = static_cast<int>(i);
    }
  }
}

void CopyTimePoints(const span<const float>& _times, float _inv_duration,
                    const span<float>& _ratios) {
  assert(_times.size() == _ratios.size());
  for (size_t i = 0; i < _times.size(); ++i) {
    _ratios[i] = _times[i] * _inv_duration;
  }
}

uint16_t TimePointToIndex(const span<const float>& _timepoints, float _time) {
  const float* found =
      std::lower_bound(_timepoints.begin(), _timepoints.end(), _time);
  assert(found != _timepoints.end() && *found == _time);
  const ptrdiff_t distance = found - _timepoints.begin();
  assert(distance >= 0 && distance < std::numeric_limits<uint16_t>::max());
  return static_cast<uint16_t>(distance);
}

template <typename _SortingKey, typename _DestKey, typename _Compressor>
void Compress(const span<const float>& _timepoints,
              const span<_SortingKey>& _src, size_t _num_tracks,
              const span<_DestKey> _dest, const Animation::KeyframesCtrl& _base,
              const _Compressor& _compressor) {
  ozz::vector<_DestKey*> previouses(_num_tracks);
  for (size_t i = 0; i < _src.size(); ++i) {
    const _SortingKey& src = _src[i];
    _DestKey& dest_key = _dest[i];

    // Ratio
    const uint16_t ratio = TimePointToIndex(_timepoints, src.key.time);
    if (_timepoints.size() <= std::numeric_limits<uint8_t>::max()) {
      assert(ratio <= std::numeric_limits<uint8_t>::max());
      reinterpret_span<uint8_t>(_base.ratios)[i] = static_cast<uint8_t>(ratio);
    } else {
      reinterpret_span<uint16_t>(_base.ratios)[i] = ratio;
    }

    // Previous
    const ptrdiff_t diff =
        previouses[src.track] ? &dest_key - previouses[src.track] : 0;
    assert(diff < ozz::animation::internal::kMaxPreviousOffset);
    _base.previouses[i] = static_cast<uint16_t>(diff);

    // Value
    _compressor(src.key.value, &dest_key);

    // Stores track position
    previouses[src.track] = &dest_key;
  }
}

void CompressFloat3(const ozz::math::Float3& _src,
                    ozz::animation::internal::Float3Key* _dest) {
  _dest->values[0] = ozz::math::FloatToHalf(_src.x);
  _dest->values[1] = ozz::math::FloatToHalf(_src.y);
  _dest->values[2] = ozz::math::FloatToHalf(_src.z);
}

// Compares float absolute values.
bool LessAbs(float _left, float _right) {
  return std::abs(_left) < std::abs(_right);
}

// Compresses quaternion to ozz::animation::RotationKey format.
// The 3 smallest components of the quaternion are quantized to x bits
// integers, while the largest is recomputed thanks to quaternion
// normalization property (x^2+y^2+z^2+w^2 = 1). Because the 3 components are
// the 3 smallest, their value cannot be greater than sqrt(2)/2. Thus
// quantization quality is improved by pre-multiplying each componenent by
// sqrt(2).
void CompressQuaternion(const ozz::math::Quaternion& _src,
                        ozz::animation::internal::QuaternionKey* _dest) {
  // Finds the largest quaternion component.
  const float quat[4] = {_src.x, _src.y, _src.z, _src.w};
  const ptrdiff_t largest = std::max_element(quat, quat + 4, LessAbs) - quat;
  assert(largest <= 3);

  // Quantize the 3 smallest components on x bits signed integers.
  const float kScale = internal::QuaternionKey::kfScale / math::kSqrt2;
  const float kOffset = -math::kSqrt2_2;
  const int kMapping[4][3] = {{1, 2, 3}, {0, 2, 3}, {0, 1, 3}, {0, 1, 2}};
  const int* map = kMapping[largest];
  const int cpnt[3] = {
      math::Min(static_cast<int>((quat[map[0]] - kOffset) * kScale + .5f),
                internal::QuaternionKey::kiScale),
      math::Min(static_cast<int>((quat[map[1]] - kOffset) * kScale + .5f),
                internal::QuaternionKey::kiScale),
      math::Min(static_cast<int>((quat[map[2]] - kOffset) * kScale + .5f),
                internal::QuaternionKey::kiScale)};

  pack(static_cast<int>(largest), quat[largest] < 0.f, cpnt, _dest);
}  // namespace

// Normalize quaternions. Fixes-up successive opposite quaternions that would
// fail to take the shortest path during the normalized-lerp. Note that keys
// are still sorted per-track at that point, which allows this algorithm to
// process all consecutive keys.
void FixupQuaternions(ozz::vector<SortingQuaternionKey>* _src) {
  size_t track = std::numeric_limits<size_t>::max();
  const math::Quaternion identity = math::Quaternion::identity();
  for (size_t i = 0; i < _src->size(); ++i) {
    SortingQuaternionKey& src = _src->at(i);
    math::Quaternion normalized = NormalizeSafe(src.key.value, identity);
    if (track != _src->at(i).track) {  // First key of the track.
      if (normalized.w < 0.f) {    // .w eq to a dot with identity quaternion.
        normalized = -normalized;  // Q an -Q are the same rotation.
      }
    } else {  // Still on the same track: so fixes-up quaternion.
      const SortingQuaternionKey& prev_src = _src->at(i - 1);
      const math::Float4 prev(prev_src.key.value.x, prev_src.key.value.y,
                              prev_src.key.value.z, prev_src.key.value.w);
      const math::Float4 curr(normalized.x, normalized.y, normalized.z,
                              normalized.w);
      if (Dot(prev, curr) < 0.f) {
        normalized = -normalized;  // Q an -Q are the same rotation.
      }
    }
    // Stores fixed-up quaternion.
    src.key.value = normalized;
    track = src.track;
  }
}

ozz::vector<float> BuildTimePoints(
    ozz::vector<SortingTranslationKey>& _translations,
    ozz::vector<SortingQuaternionKey>& _rotations,
    ozz::vector<SortingScaleKey>& _scales) {
  ozz::vector<float> timepoints;

  for (const auto& _key : _translations) {
    timepoints.push_back(_key.key.time);
  }
  for (const auto& _key : _rotations) {
    timepoints.push_back(_key.key.time);
  }
  for (const auto& _key : _scales) {
    timepoints.push_back(_key.key.time);
  }

  std::sort(timepoints.begin(), timepoints.end());
  timepoints.erase(std::unique(timepoints.begin(), timepoints.end()),
                   timepoints.end());

  return timepoints;
}

struct BuilderIFrame {
  ozz::vector<byte> entries;
  size_t last;
};

template <typename _SortingKey>
BuilderIFrame BuildIFrame(const ozz::span<_SortingKey>& _src, float _time,
                          size_t _num_soa_tracks) {
  BuilderIFrame iframe;

  // Initialize vector with initial cached keys at t=0. Due to sorting, they
  // are the 2nd set keyframes, hence starting from _num_soa_tracks.
  const uint32_t num_entries = static_cast<uint32_t>(_num_soa_tracks);
  ozz::vector<uint32_t> entries(num_entries);

  // The loop can end as soon as it finds a key greater that _time. It
  // will mean that all the keys lower than _time have been processed, meaning
  // all cache entries are up to date.
  for (size_t i = 0, end = _src.size();
       i < end && _src[i].prev_key_time <= _time; ++i) {
    // Stores the last key found for this track.
    entries[_src[i].track] = static_cast<uint32_t>(i);
    iframe.last = i;
  }
  assert(iframe.last >= _num_soa_tracks * 2 - 1);

  // Compress buffer.
  const size_t worst_size = ozz::ComputeGV4WorstBufferSize(make_span(entries));
  iframe.entries.resize(worst_size);
  auto remain =
      ozz::EncodeGV4Stream(make_span(entries), make_span(iframe.entries));
  iframe.entries.resize(iframe.entries.size() - remain.size_bytes());

  return iframe;
}

struct BuilderIFrames {
  ozz::vector<byte> entries;
  ozz::vector<uint32_t> desc;
  float interval = 1.f;
};

// Splits src into parts of similar sizes. The "time" of each part doesn't
// really matter, it's the number of keys that impact performance.
template <typename _SortingKey>
BuilderIFrames BuildIFrames(const ozz::span<_SortingKey>& _src,
                            size_t _num_soa_tracks, float _interval,
                            float _duration) {
  BuilderIFrames iframes;
  if (_num_soa_tracks == 0 || _interval <= 0.f) {
    return iframes;
  }

  const size_t iframes_divs = static_cast<size_t>(_duration / _interval);
  for (size_t i = 0; i < iframes_divs; ++i) {
    const float time = _duration * (i + 1) / iframes_divs;
    const auto& iframe = BuildIFrame(_src, time, _num_soa_tracks);

    // Don't need to add an iframe for the first set of keyframes.
    if (iframe.last <= _num_soa_tracks * 2 - 1) {
      continue;
    }

    // Don't need to append an iframe if there's not enough keyframes between
    // two iframes.
    if (!iframes.desc.empty() && iframe.last <= iframes.desc.back()) {
      continue;
    }

    // Pushes offset.
    iframes.desc.push_back(static_cast<uint32_t>(iframes.entries.size()));
    iframes.desc.push_back(static_cast<uint32_t>(iframe.last));

    // Pushes compressed data.
    iframes.entries.insert(iframes.entries.end(), iframe.entries.begin(),
                           iframe.entries.end());
  }

  // Computes actual interval (duration ratio) between iframes.
  const size_t actual_intervals = iframes.desc.size() / 2;
  iframes.interval = iframes.entries.empty() ? 1.f : 1.f / actual_intervals;
  return iframes;
}

void CopyIFrames(const BuilderIFrames& _src, Animation::KeyframesCtrl& _dest) {
  assert(_dest.iframe_entries.size() == _src.entries.size());
  std::copy(_src.entries.begin(), _src.entries.end(),
            _dest.iframe_entries.begin());
  assert(_dest.iframe_desc.size() == _src.desc.size());
  std::copy(_src.desc.begin(), _src.desc.end(), _dest.iframe_desc.begin());
  _dest.iframe_interval = _src.interval;
}
}  // namespace

// Ensures _input's validity and allocates _animation.
// An animation needs to have at least two key frames per joint, the first at
// t = 0 and the last at t = duration. If at least one of those keys are not
// in the RawAnimation then the builder creates it.
unique_ptr<Animation> AnimationBuilder::operator()(
    const RawAnimation& _input) const {
  // Tests _raw_animation validity.
  if (!_input.Validate()) {
    return nullptr;
  }

  // Everything is fine, allocates and fills the animation.
  // Nothing can fail now.
  unique_ptr<Animation> animation = make_unique<Animation>();

  // Sets duration.
  const float duration = _input.duration;
  // A _duration == 0 would create some division by 0 during sampling.
  // Also we need at least to keys with different times, which cannot be done
  // if duration is 0.
  assert(duration > 0.f);  // This case is handled by Validate().
  const float inv_duration = 1.f / _input.duration;
  animation->duration_ = duration;

  // Sets tracks count. Can be safely casted to uint16_t as number of tracks as
  // already been validated.
  const uint16_t num_tracks = static_cast<uint16_t>(_input.num_tracks());
  animation->num_tracks_ = num_tracks;
  const uint16_t num_soa_tracks = Align(num_tracks, 4);

  // Declares and preallocates tracks to sort.
  size_t translations = 0, rotations = 0, scales = 0;
  for (uint16_t i = 0; i < num_tracks; ++i) {
    const RawAnimation::JointTrack& raw_track = _input.tracks[i];
    translations += raw_track.translations.size() + 2;  // +2 because worst case
    rotations += raw_track.rotations.size() + 2;        // needs to add the
    scales += raw_track.scales.size() + 2;              // first and last keys.
  }
  ozz::vector<SortingTranslationKey> sorting_translations;
  sorting_translations.reserve(translations);
  ozz::vector<SortingQuaternionKey> sorting_rotations;
  sorting_rotations.reserve(rotations);
  ozz::vector<SortingScaleKey> sorting_scales;
  sorting_scales.reserve(scales);

  // Filters RawAnimation keys and copies them to the output sorting structure.
  uint16_t i = 0;
  for (; i < num_tracks; ++i) {
    const RawAnimation::JointTrack& raw_track = _input.tracks[i];
    CopyRaw(raw_track.translations, i, duration, &sorting_translations);
    CopyRaw(raw_track.rotations, i, duration, &sorting_rotations);
    CopyRaw(raw_track.scales, i, duration, &sorting_scales);
  }

  // Add enough identity keys to match soa requirements.
  for (; i < num_soa_tracks; ++i) {
    typedef RawAnimation::TranslationKey SrcTKey;
    PushBackIdentityKey<SrcTKey>(i, 0.f, &sorting_translations);
    PushBackIdentityKey<SrcTKey>(i, duration, &sorting_translations);

    typedef RawAnimation::RotationKey SrcRKey;
    PushBackIdentityKey<SrcRKey>(i, 0.f, &sorting_rotations);
    PushBackIdentityKey<SrcRKey>(i, duration, &sorting_rotations);

    typedef RawAnimation::ScaleKey SrcSKey;
    PushBackIdentityKey<SrcSKey>(i, 0.f, &sorting_scales);
    PushBackIdentityKey<SrcSKey>(i, duration, &sorting_scales);
  }

  FixupQuaternions(&sorting_rotations);

  // Sort animation keys to favor cache coherency.
  Sort(sorting_translations, num_soa_tracks, &LerpTranslation,
       &SortingKeyLess<SortingTranslationKey>);
  Sort(sorting_rotations, num_soa_tracks, &LerpRotation,
       &SortingKeyLess<SortingQuaternionKey>);
  Sort(sorting_scales, num_soa_tracks, &LerpScale,
       &SortingKeyLess<SortingScaleKey>);

  // Get all timepoints. Shall be done on sorting keys as time points might have
  // been added during the process.
  const ozz::vector<float>& time_points =
      BuildTimePoints(sorting_translations, sorting_rotations, sorting_scales);

  // Maximum time points reached.
  if (time_points.size() > std::numeric_limits<uint16_t>::max()) {
    return nullptr;
  }

  // Maximum number of keys reached.
  if (sorting_translations.size() > std::numeric_limits<uint32_t>::max() &&
      sorting_rotations.size() > std::numeric_limits<uint32_t>::max() &&
      sorting_scales.size() > std::numeric_limits<uint32_t>::max()) {
    return nullptr;
  }

  // Build cache snaphots/iframes.
  const auto& translation_ss =
      BuildIFrames(make_span(sorting_translations), num_soa_tracks,
                   iframe_interval, duration);
  const auto& rotation_ss = BuildIFrames(
      make_span(sorting_rotations), num_soa_tracks, iframe_interval, duration);
  const auto& scale_ss = BuildIFrames(make_span(sorting_scales), num_soa_tracks,
                                      iframe_interval, duration);

  // Allocate animation members.
  const Animation::AllocateParams params{
      _input.name.length(),
      time_points.size(),
      sorting_translations.size(),
      sorting_rotations.size(),
      sorting_scales.size(),
      {translation_ss.entries.size(), translation_ss.desc.size()},
      {rotation_ss.entries.size(), rotation_ss.desc.size()},
      {scale_ss.entries.size(), scale_ss.desc.size()}};
  animation->Allocate(params);

  CopyIFrames(translation_ss, animation->translations_ctrl_);
  CopyIFrames(rotation_ss, animation->rotations_ctrl_);
  CopyIFrames(scale_ss, animation->scales_ctrl_);

  // Copy sorted keys to final animation.
  Compress(make_span(time_points), make_span(sorting_translations),
           num_soa_tracks, make_span(animation->translations_values_),
           animation->translations_ctrl_, &CompressFloat3);
  Compress(make_span(time_points), make_span(sorting_rotations), num_soa_tracks,
           make_span(animation->rotations_values_), animation->rotations_ctrl_,
           &CompressQuaternion);
  Compress(make_span(time_points), make_span(sorting_scales), num_soa_tracks,
           make_span(animation->scales_values_), animation->scales_ctrl_,
           &CompressFloat3);

  // Converts timepoints to ratio and copy to animation. Must be done once
  // indices have been set.
  CopyTimePoints(make_span(time_points), inv_duration, animation->timepoints_);

  // Copy animation's name.
  if (animation->name_) {
    strcpy(animation->name_, _input.name.c_str());
  }

  return animation;  // Success.
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including animation_optimizer.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/animation_optimizer.h"

#include <cassert>
#include <cstddef>
#include <functional>

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/offline/decimate.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_DECIMATE_H_
#define OZZ_ANIMATION_OFFLINE_DECIMATE_H_

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

#include "ozz/base/containers/stack.h"
#include "ozz/base/containers/vector.h"

#include <cassert>

namespace ozz {
namespace animation {
namespace offline {

// Decimation algorithm based on Ramer-Douglas-Peucker.
// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
// _Track must have std::vector interface.
// Adapter must have the following interface:
// struct Adapter {
//  bool Decimable(const Key&) const;
//  Key Lerp(const Key& _left, const Key& _right, const Key& _ref) const;
//  float Distance(const Key& _a, const Key& _b) const;
// };
template <typename _Track, typename _Adapter>
void Decimate(const _Track& _src, const _Adapter& _adapter, float _tolerance,
              _Track* _dest) {
  // Early out if not enough data.
  if (_src.size() < 2) {
    *_dest = _src;
    return;
  }

  // Stack of segments to process.
  typedef std::pair<size_t, size_t> Segment;
  ozz::stack<Segment> segments;

  // Bit vector of all points to included.
  ozz::vector<bool> included(_src.size(), false);

  // Pushes segment made from first and last points.
  segments.push(Segment(0, _src.size() - 1));
  included[0] = true;
  included[_src.size() - 1] = true;

  // Empties segments stack.
  while (!segments.empty()) {
    // Pops next segment to process.
    const Segment segment = segments.top();
    segments.pop();

    // Looks for the furthest point from the segment.
    float max = -1.f;
    size_t candidate = segment.first;
    typename _Track::const_reference left = _src[segment.first];
    typename _Track::const_reference right = _src[segment.second];
    for (size_t i = segment.first + 1; i < segment.second; ++i) {
      assert(!included[i] && "Included points should be processed once only.");
      typename _Track::const_reference test = _src[i];
      if (!_adapter.Decimable(test)) {
        candidate = i;
        break;
      } else {
        const float distance =
            _adapter.Distance(_adapter.Lerp(left, right, test), test);
        if (distance > _tolerance && distance > max) {
          max = distance;
          candidate = i;
        }
      }
    }

    // If found, include the point and pushes the 2 new segments (before and
    // after the new point).
    if (candidate != segment.first) {
      included[candidate] = true;
      if (candidate - segment.first > 1) {
        segments.push(Segment(segment.first, candidate));
      }
      if (segment.second - candidate > 1) {
        segments.push(Segment(candidate, segment.second));
      }
    }
  }

  // Copy all included points.
  _dest->clear();
  for (size_t i = 0; i < _src.size(); ++i) {
    if (included[i]) {
      _dest->push_back(_src[i]);
    }
  }

  // Removes last key if constant.
  if (_dest->size() > 1) {
    typename _Track::const_iterator end = _dest->end();
    typename _Track::const_reference last = *(--end);
    typename _Track::const_reference penultimate = *(--end);
    const float distance = _adapter.Distance(penultimate, last);
    if (_adapter.Decimable(last) && distance <= _tolerance) {
      _dest->pop_back();
    }
  }
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_DECIMATE_H_

#include "ozz/animation/offline/raw_animation.h"
#include "ozz/animation/offline/raw_animation_utils.h"
#include "ozz/animation/runtime/skeleton.h"
#include "ozz/animation/runtime/skeleton_utils.h"
#include "ozz/base/containers/stack.h"
#include "ozz/base/containers/vector.h"
#include "ozz/base/maths/math_constant.h"
#include "ozz/base/maths/math_ex.h"

namespace ozz {
namespace animation {
namespace offline {

// Setup default values (favoring quality).
AnimationOptimizer::AnimationOptimizer() {}

namespace {

AnimationOptimizer::Setting GetJointSetting(
    const AnimationOptimizer& _optimizer, int _joint) {
  AnimationOptimizer::Setting setting = _optimizer.setting;
  AnimationOptimizer::JointsSetting::const_iterator it =
      _optimizer.joints_setting_override.find(_joint);
  if (it != _optimizer.joints_setting_override.end()) {
    setting = it->second;
  }
  return setting;
}

struct HierarchyBuilder {
  HierarchyBuilder(const RawAnimation* _animation, const Skeleton* _skeleton,
                   const AnimationOptimizer* _optimizer)
      : specs(_animation->tracks.size()),
        animation(_animation),
        optimizer(_optimizer) {
    assert(_animation->num_tracks() == _skeleton->num_joints());

    // Computes hierarchical scale, iterating skeleton forward (root to
    // leaf).
    IterateJointsDF(*_skeleton,
                    std::bind(&HierarchyBuilder::ComputeScaleForward, this,
                              std::placeholders::_1, std::placeholders::_2));

    // Computes hierarchical length, iterating skeleton backward (leaf to root).
    IterateJointsDFReverse(
        *_skeleton, std::bind(&HierarchyBuilder::ComputeLengthBackward, this,
                              std::placeholders::_1, std::placeholders::_2));
  }

  struct Spec {
    float length;  // Length of a joint hierarchy (max of all child).
    float scale;   // Scale of a joint hierarchy (accumulated from all parents).
    float tolerance;  // Tolerance of a joint hierarchy (min of all child).
  };

  // Defines the length of a joint hierarchy (of all child).
  ozz::vector<Spec> specs;

 private:
  // Extracts maximum translations and scales for each track/joint.
  void ComputeScaleForward(int _joint, int _parent) {
    Spec& joint_spec = specs[_joint];

    // Compute joint maximum animated scale.
    float max_scale = 0.f;
    const RawAnimation::JointTrack& track = animation->tracks[_joint];
    if (track.scales.size() != 0) {
      for (size_t j = 0; j < track.scales.size(); ++j) {
        const math::Float3& scale = track.scales[j].value;
        const float max_element = math::Max(
            math::Max(std::abs(scale.x), std::abs(scale.y)), std::abs(scale.z));
        max_scale = math::Max(max_scale, max_element);
      }
    } else {
      max_scale = 1.f;  // Default scale.
    }

    // Accumulate with parent scale.
    joint_spec.scale = max_scale;
    if (_parent != Skeleton::kNoParent) {
      const Spec& parent_spec = specs[_parent];
      joint_spec.scale *= parent_spec.scale;
    }

    // Computes self setting distance and tolerance.
    // Distance is now scaled with accumulated parent scale.
    const AnimationOptimizer::Setting setting =
        GetJointSetting(*optimizer, _joint);
    joint_spec.length = setting.distance * specs[_joint].scale;
    joint_spec.tolerance = setting.tolerance;
  }

  // Propagate child translations back to the root.
  void ComputeLengthBackward(int _joint, int _parent) {
    // Self translation doesn't matter if joint has no parent.
    if (_parent == Skeleton::kNoParent) {
      return;
    }

    // Compute joint maximum animated length.
    float max_length_sq = 0.f;
    const RawAnimation::JointTrack& track = animation->tracks[_joint];
    for (size_t j = 0; j < track.translations.size(); ++j) {
      max_length_sq =
          math::Max(max_length_sq, LengthSqr(track.translations[j].value));
    }
    const float max_length = std::sqrt(max_length_sq);

    const Spec& joint_spec = specs[_joint];
    Spec& parent_spec = specs[_parent];

    // Set parent hierarchical spec to its most impacting child, aka max
    // length and min tolerance.
    parent_spec.length = math::Max(
        parent_spec.length, joint_spec.length + max_length * parent_spec.scale);
    parent_spec.tolerance =
        math::Min(parent_spec.tolerance, joint_spec.tolerance);
  }

  // Disables copy and assignment.
  HierarchyBuilder(const HierarchyBuilder&);
  void operator=(const HierarchyBuilder&);

  // Targeted animation.
  const RawAnimation* animation;

  // Usefull to access settings and compute hierarchy length.
  const AnimationOptimizer* optimizer;
};

class PositionAdapter {
 public:
  PositionAdapter(float _scale) : scale_(_scale) {}
  bool Decimable(const RawAnimation::TranslationKey&) const { return true; }
  RawAnimation::TranslationKey Lerp(
      const RawAnimation::TranslationKey& _left,
      const RawAnimation::TranslationKey& _right,
      const RawAnimation::TranslationKey& _ref) const {
    const float alpha = (_ref.time - _left.time) / (_right.time - _left.time);
    assert(alpha >= 0.f && alpha <= 1.f);
    const RawAnimation::TranslationKey key = {
        _ref.time, LerpTranslation(_left.value, _right.value, alpha)};
    return key;
  }
  float Distance(const RawAnimation::TranslationKey& _a,
                 const RawAnimation::TranslationKey& _b) const {
    return Length(_a.value - _b.value) * scale_;
  }

 private:
  float scale_;
};

class RotationAdapter {
 public:
  RotationAdapter(float _radius) : radius_(_radius) {}
  bool Decimable(const RawAnimation::RotationKey&) const { return true; }
  RawAnimation::RotationKey Lerp(const RawAnimation::RotationKey& _left,
                                 const RawAnimation::RotationKey& _right,
                                 const RawAnimation::RotationKey& _ref) const {
    const float alpha = (_ref.time - _left.time) / (_right.time - _left.time);
    assert(alpha >= 0.f && alpha <= 1.f);
    const RawAnimation::RotationKey key = {
        _ref.time, LerpRotation(_left.value, _right.value, alpha)};
    return key;
  }
  float Distance(const RawAnimation::RotationKey& _left,
                 const RawAnimation::RotationKey& _right) const {
    // Compute the shortest unsigned angle between the 2 quaternions.
    // cos_half_angle is w component of a-1 * b.
    const float cos_half_angle = Dot(_left.value, _right.value);
    const float sine_half_angle =
        std::sqrt(1.f - math::Min(1.f, cos_half_angle * cos_half_angle));
    // Deduces distance between 2 points on a circle with radius and a given
    // angle. Using half angle helps as it allows to have a right-angle
    // triangle.
    const float distance = 2.f * sine_half_angle * radius_;
    return distance;
  }

 private:
  float radius_;
};

class ScaleAdapter {
 public:
  ScaleAdapter(float _length) : length_(_length) {}
  bool Decimable(const RawAnimation::ScaleKey&) const { return true; }
  RawAnimation::ScaleKey Lerp(const RawAnimation::ScaleKey& _left,
                              const RawAnimation::ScaleKey& _right,
                              const RawAnimation::ScaleKey& _ref) const {
    const float alpha = (_ref.time - _left.time) / (_right.time - _left.time);
    assert(alpha >= 0.f && alpha <= 1.f);
    const RawAnimation::ScaleKey key = {
        _ref.time, LerpScale(_left.value, _right.value, alpha)};
    return key;
  }
  float Distance(const RawAnimation::ScaleKey& _left,
                 const RawAnimation::ScaleKey& _right) const {
    return Length(_left.value - _right.value) * length_;
  }

 private:
  float length_;
};
}  // namespace

bool AnimationOptimizer::operator()(const RawAnimation& _input,
                                    const Skeleton& _skeleton,
                                    RawAnimation* _output) const {
  if (!_output) {
    return false;
  }
  // Reset output animation to default.
  *_output = RawAnimation();

  // Validate animation.
  if (!_input.Validate()) {
    return false;
  }

  const int num_tracks = _input.num_tracks();

  // Validates the skeleton matches the animation.
  if (num_tracks != _skeleton.num_joints()) {
    return false;
  }

  // First computes bone lengths, that will be used when filtering.
  const HierarchyBuilder hierarchy(&_input, &_skeleton, this);

  // Rebuilds output animation.
  _output->name = _input.name;
  _output->duration = _input.duration;
  _output->tracks.resize(num_tracks);

  for (int i = 0; i < num_tracks; ++i) {
    const RawAnimation::JointTrack& input = _input.tracks[i];
    RawAnimation::JointTrack& output = _output->tracks[i];

    // Gets joint specs back.
    const float joint_length = hierarchy.specs[i].length;
    const int parent = _skeleton.joint_parents()[i];
    const float parent_scale =
        (parent != Skeleton::kNoParent) ? hierarchy.specs[parent].scale : 1.f;
    const float tolerance = hierarchy.specs[i].tolerance;

    // Filters independently T, R and S tracks.
    // This joint translation is affected by parent scale.
    const PositionAdapter tadap(parent_scale);
    Decimate(input.translations, tadap, tolerance, &output.translations);
    // This joint rotation affects children translations/length.
    const RotationAdapter radap(joint_length);
    Decimate(input.rotations, radap, tolerance, &output.rotations);
    // This joint scale affects children translations/length.
    const ScaleAdapter sadap(joint_length);
    Decimate(input.scales, sadap, tolerance, &output.scales);
  }

  // Output animation is always valid though.
  return _output->Validate();
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including additive_animation_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/additive_animation_builder.h"

#include <cassert>
#include <cstddef>

#include "ozz/animation/offline/raw_animation.h"
#include "ozz/base/maths/transform.h"

namespace ozz {
namespace animation {
namespace offline {

namespace {
template <typename _RawTrack, typename _RefType, typename _MakeDelta>
void MakeDelta(const _RawTrack& _src, const _RefType& reference,
               const _MakeDelta& _make_delta, _RawTrack* _dest) {
  _dest->reserve(_src.size());

  // Early out if no key.
  if (_src.empty()) {
    return;
  }

  // Copy animation keys.
  for (size_t i = 0; i < _src.size(); ++i) {
    const typename _RawTrack::value_type delta = {
        _src[i].time, _make_delta(reference, _src[i].value)};
    _dest->push_back(delta);
  }
}

math::Float3 MakeDeltaTranslation(const math::Float3& _reference,
                                  const math::Float3& _value) {
  return _value - _reference;
}

math::Quaternion MakeDeltaRotation(const math::Quaternion& _reference,
                                   const math::Quaternion& _value) {
  return Conjugate(_reference) * _value;
}

math::Float3 MakeDeltaScale(const math::Float3& _reference,
                            const math::Float3& _value) {
  return _value / _reference;
}
}  // namespace

// Setup default values (favoring quality).
AdditiveAnimationBuilder::AdditiveAnimationBuilder() {}

bool AdditiveAnimationBuilder::operator()(const RawAnimation& _input,
                                          RawAnimation* _output) const {
  if (!_output) {
    return false;
  }
  // Reset output animation to default.
  *_output = RawAnimation();

  // Validate animation.
  if (!_input.Validate()) {
    return false;
  }

  // Rebuilds output animation.
  _output->name = _input.name;
  _output->duration = _input.duration;
  _output->tracks.resize(_input.tracks.size());

  for (size_t i = 0; i < _input.tracks.size(); ++i) {
    const RawAnimation::JointTrack& track_in = _input.tracks[i];
    RawAnimation::JointTrack& track_out = _output->tracks[i];

    const RawAnimation::JointTrack::Translations& translations =
        track_in.translations;
    const math::Float3 ref_translation =
        translations.size() > 0 ? translations[0].value : math::Float3::zero();

    const RawAnimation::JointTrack::Rotations& rotations = track_in.rotations;
    const math::Quaternion ref_rotation = rotations.size() > 0
                                              ? rotations[0].value
                                              : math::Quaternion::identity();

    const RawAnimation::JointTrack::Scales& scales = track_in.scales;
    const math::Float3 ref_scale =
        scales.size() > 0 ? scales[0].value : math::Float3::one();

    MakeDelta(translations, ref_translation, MakeDeltaTranslation,
              &track_out.translations);
    MakeDelta(rotations, ref_rotation, MakeDeltaRotation, &track_out.rotations);
    MakeDelta(scales, ref_scale, MakeDeltaScale, &track_out.scales);
  }

  // Output animation is always valid though.
  return _output->Validate();
}

bool AdditiveAnimationBuilder::operator()(
    const RawAnimation& _input,
    const span<const math::Transform>& _reference_pose,
    RawAnimation* _output) const {
  if (!_output) {
    return false;
  }

  // Reset output animation to default.
  *_output = RawAnimation();

  // Validate animation.
  if (!_input.Validate()) {
    return false;
  }

  // The reference pose must have at least the same number of
  // tracks as the raw animation.
  if (_input.num_tracks() > static_cast<int>(_reference_pose.size())) {
    return false;
  }

  // Rebuilds output animation.
  _output->name = _input.name;
  _output->duration = _input.duration;
  _output->tracks.resize(_input.tracks.size());

  for (size_t i = 0; i < _input.tracks.size(); ++i) {
    MakeDelta(_input.tracks[i].translations, _reference_pose[i].translation,
              MakeDeltaTranslation, &_output->tracks[i].translations);
    MakeDelta(_input.tracks[i].rotations, _reference_pose[i].rotation,
              MakeDeltaRotation, &_output->tracks[i].rotations);
    MakeDelta(_input.tracks[i].scales, _reference_pose[i].scale, MakeDeltaScale,
              &_output->tracks[i].scales);
  }

  // Output animation is always valid though.
  return _output->Validate();
}

}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_skeleton.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_skeleton.h"

#include "ozz/animation/runtime/skeleton.h"

namespace ozz {
namespace animation {
namespace offline {

RawSkeleton::RawSkeleton() {}

RawSkeleton::~RawSkeleton() {}

bool RawSkeleton::Validate() const {
  if (num_joints() > Skeleton::kMaxJoints) {
    return false;
  }
  return true;
}

namespace {
struct JointCounter {
  JointCounter() : num_joints(0) {}
  void operator()(const RawSkeleton::Joint&, const RawSkeleton::Joint*) {
    ++num_joints;
  }
  int num_joints;
};
}  // namespace

// Iterates through all the root children and count them.
int RawSkeleton::num_joints() const {
  return IterateJointsDF(*this, JointCounter()).num_joints;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_skeleton_archive.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_skeleton.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/maths/math_archive.h"

#include "ozz/base/containers/string_archive.h"
#include "ozz/base/containers/vector_archive.h"

namespace ozz {
namespace io {

void Extern<animation::offline::RawSkeleton>::Save(
    OArchive& _archive, const animation::offline::RawSkeleton* _skeletons,
    size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawSkeleton& skeleton = _skeletons[i];
    _archive << skeleton.roots;
  }
}
void Extern<animation::offline::RawSkeleton>::Load(
    IArchive& _archive, animation::offline::RawSkeleton* _skeletons,
    size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawSkeleton& skeleton = _skeletons[i];
    _archive >> skeleton.roots;
  }
}

// RawSkeleton::Joint' version can be declared locally as it will be saved from
// this cpp file only.
OZZ_IO_TYPE_VERSION(1, animation::offline::RawSkeleton::Joint)

template <>
struct Extern<animation::offline::RawSkeleton::Joint> {
  static void Save(OArchive& _archive,
                   const animation::offline::RawSkeleton::Joint* _joints,
                   size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::offline::RawSkeleton::Joint& joint = _joints[i];
      _archive << joint.name;
      _archive << joint.transform;
      _archive << joint.children;
    }
  }
  static void Load(IArchive& _archive,
                   animation::offline::RawSkeleton::Joint* _joints,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::offline::RawSkeleton::Joint& joint = _joints[i];
      _archive >> joint.name;
      _archive >> joint.transform;
      _archive >> joint.children;
    }
  }
};
}  // namespace io
}  // namespace ozz

// Including skeleton_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/skeleton_builder.h"

#include <cstring>

#include "ozz/animation/offline/raw_skeleton.h"
#include "ozz/animation/runtime/skeleton.h"
#include "ozz/base/containers/vector.h"
#include "ozz/base/maths/soa_transform.h"
#include "ozz/base/memory/allocator.h"

namespace ozz {
namespace animation {
namespace offline {

namespace {
// Stores each traversed joint in a vector.
struct JointLister {
  explicit JointLister(int _num_joints) { linear_joints.reserve(_num_joints); }
  void operator()(const RawSkeleton::Joint& _current,
                  const RawSkeleton::Joint* _parent) {
    // Looks for the "lister" parent.
    int16_t parent = Skeleton::kNoParent;
    if (_parent) {
      // Start searching from the last joint.
      int16_t j = static_cast<int16_t>(linear_joints.size()) - 1;
      for (; j >= 0; --j) {
        if (linear_joints[j].joint == _parent) {
          parent = j;
          break;
        }
      }
      assert(parent >= 0);
    }
    const Joint listed = {&_current, parent};
    linear_joints.push_back(listed);
  }
  struct Joint {
    const RawSkeleton::Joint* joint;
    int16_t parent;
  };
  // Array of joints in the traversed DAG order.
  ozz::vector<Joint> linear_joints;
};
}  // namespace

// Validates the RawSkeleton and fills a Skeleton.
// Uses RawSkeleton::IterateJointsDF to traverse in DAG depth-first order.
// Building skeleton hierarchy in depth first order make it easier to iterate a
// skeleton sub-hierarchy.
unique_ptr<ozz::animation::Skeleton> SkeletonBuilder::operator()(
    const RawSkeleton& _raw_skeleton) const {
  // Tests _raw_skeleton validity.
  if (!_raw_skeleton.Validate()) {
    return nullptr;
  }

  // Everything is fine, allocates and fills the skeleton.
  // Will not fail.
  unique_ptr<ozz::animation::Skeleton> skeleton = make_unique<Skeleton>();
  const int num_joints = _raw_skeleton.num_joints();

  // Iterates through all the joint of the raw skeleton and fills a sorted joint
  // list.
  // Iteration order defines runtime skeleton joint ordering.
  JointLister lister(num_joints);
  IterateJointsDF<JointLister&>(_raw_skeleton, lister);
  assert(static_cast<int>(lister.linear_joints.size()) == num_joints);

  // Computes name's buffer size.
  size_t chars_size = 0;
  for (int i = 0; i < num_joints; ++i) {
    const RawSkeleton::Joint& current = *lister.linear_joints[i].joint;
    chars_size += (current.name.size() + 1) * sizeof(char);
  }

  // Allocates all skeleton members.
  char* cursor = skeleton->Allocate(chars_size, num_joints);

  // Copy names. All names are allocated in a single buffer. Only the first name
  // is set, all other names array entries must be initialized.
  for (int i = 0; i < num_joints; ++i) {
    const RawSkeleton::Joint& current = *lister.linear_joints[i].joint;
    skeleton->joint_names_[i] = cursor;
    strcpy(cursor, current.name.c_str());
    cursor += (current.name.size() + 1) * sizeof(char);
  }

  // Transfers sorted joints hierarchy to the new skeleton.
  for (int i = 0; i < num_joints; ++i) {
    skeleton->joint_parents_[i] = lister.linear_joints[i].parent;
  }

  // Transfers t-poses.
  const math::SimdFloat4 w_axis = math::simd_float4::w_axis();
  const math::SimdFloat4 zero = math::simd_float4::zero();
  const math::SimdFloat4 one = math::simd_float4::one();

  for (int i = 0; i < skeleton->num_soa_joints(); ++i) {
    math::SimdFloat4 translations[4];
    math::SimdFloat4 scales[4];
    math::SimdFloat4 rotations[4];
    for (int j = 0; j < 4; ++j) {
      if (i * 4 + j < num_joints) {
        const RawSkeleton::Joint& src_joint =
            *lister.linear_joints[i * 4 + j].joint;
        translations[j] =
            math::simd_float4::Load3PtrU(&src_joint.transform.translation.x);
        rotations[j] = math::NormalizeSafe4(
            math::simd_float4::LoadPtrU(&src_joint.transform.rotation.x),
            w_axis);
        scales[j] = math::simd_float4::Load3PtrU(&src_joint.transform.scale.x);
      } else {
        translations[j] = zero;
        rotations[j] = w_axis;
        scales[j] = one;
      }
    }
    // Fills the SoaTransform structure.
    math::Transpose4x3(translations,
                       &skeleton->joint_rest_poses_[i].translation.x);
    math::Transpose4x4(rotations, &skeleton->joint_rest_poses_[i].rotation.x);
    math::Transpose4x3(scales, &skeleton->joint_rest_poses_[i].scale.x);
  }

  return skeleton;  // Success.
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_track.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_track.h"

#include <limits>

#include "ozz/base/io/archive.h"
#include "ozz/base/maths/math_archive.h"

#include "ozz/base/containers/string_archive.h"
#include "ozz/base/containers/vector_archive.h"

namespace ozz {
namespace io {

// Can be declared locally as it's only referenced from this file.
OZZ_IO_TYPE_VERSION_T1(1, typename _ValueType,
                       animation::offline::RawTrackKeyframe<_ValueType>)

template <typename _ValueType>
struct Extern<animation::offline::RawTrackKeyframe<_ValueType>> {
  static void Save(
      OArchive& _archive,
      const animation::offline::RawTrackKeyframe<_ValueType>* _keyframes,
      size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::offline::RawTrackKeyframe<_ValueType>& keyframe =
          _keyframes[i];
      const uint8_t interp = static_cast<uint8_t>(keyframe.interpolation);
      _archive << interp;
      _archive << keyframe.ratio;
      _archive << keyframe.value;
    }
  }
  static void Load(IArchive& _archive,
                   animation::offline::RawTrackKeyframe<_ValueType>* _keyframes,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::offline::RawTrackKeyframe<_ValueType>& keyframe =
          _keyframes[i];
      uint8_t interp;
      _archive >> interp;
      keyframe.interpolation =
          static_cast<animation::offline::RawTrackInterpolation::Value>(interp);
      _archive >> keyframe.ratio;
      _archive >> keyframe.value;
    }
  }
};
}  // namespace io
namespace animation {
namespace offline {
namespace internal {

template <typename _ValueType>
bool RawTrack<_ValueType>::Validate() const {
  float previous_ratio = -1.f;
  for (size_t k = 0; k < keyframes.size(); ++k) {
    const float frame_ratio = keyframes[k].ratio;
    // Tests frame's ratio is in range [0:1].
    if (frame_ratio < 0.f || frame_ratio > 1.f) {
      return false;
    }
    // Tests that frames are sorted.
    if (frame_ratio <= previous_ratio) {
      return false;
    }
    previous_ratio = frame_ratio;
  }
  return true;  // Validated.
}

template <typename _ValueType>
void RawTrack<_ValueType>::Save(io::OArchive& _archive) const {
  _archive << keyframes;
  _archive << name;
}

template <typename _ValueType>
void RawTrack<_ValueType>::Load(io::IArchive& _archive, uint32_t _version) {
  (void)_version;
  assert(_version == 1);
  _archive >> keyframes;
  _archive >> name;
}

// Explicitly instantiate supported raw tracks.
template struct RawTrack<float>;
template struct RawTrack<math::Float2>;
template struct RawTrack<math::Float3>;
template struct RawTrack<math::Float4>;
template struct RawTrack<math::Quaternion>;
}  // namespace internal
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including track_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/track_builder.h"

#include <cassert>
#include <cmath>
#include <cstring>
#include <limits>

#include "ozz/base/memory/allocator.h"

#include "ozz/animation/offline/raw_track.h"

#include "ozz/animation/runtime/track.h"

namespace ozz {
namespace animation {
namespace offline {

namespace {

template <typename _RawTrack>
void PatchBeginEndKeys(const _RawTrack& _input,
                       typename _RawTrack::Keyframes* keyframes) {
  if (_input.keyframes.empty()) {
    const typename _RawTrack::ValueType default_value =
        animation::internal::TrackPolicy<
            typename _RawTrack::ValueType>::identity();

    const typename _RawTrack::Keyframe begin = {RawTrackInterpolation::kLinear,
                                                0.f, default_value};
    keyframes->push_back(begin);
    const typename _RawTrack::Keyframe end = {RawTrackInterpolation::kLinear,
                                              1.f, default_value};
    keyframes->push_back(end);
  } else if (_input.keyframes.size() == 1) {
    const typename _RawTrack::Keyframe& src_key = _input.keyframes.front();
    const typename _RawTrack::Keyframe begin = {RawTrackInterpolation::kLinear,
                                                0.f, src_key.value};
    keyframes->push_back(begin);
    const typename _RawTrack::Keyframe end = {RawTrackInterpolation::kLinear,
                                              1.f, src_key.value};
    keyframes->push_back(end);
  } else {
    // Copy all source data.
    // Push an initial and last keys if they don't exist.
    if (_input.keyframes.front().ratio != 0.f) {
      const typename _RawTrack::Keyframe& src_key = _input.keyframes.front();
      const typename _RawTrack::Keyframe begin = {
          RawTrackInterpolation::kLinear, 0.f, src_key.value};
      keyframes->push_back(begin);
    }
    for (size_t i = 0; i < _input.keyframes.size(); ++i) {
      keyframes->push_back(_input.keyframes[i]);
    }
    if (_input.keyframes.back().ratio != 1.f) {
      const typename _RawTrack::Keyframe& src_key = _input.keyframes.back();
      const typename _RawTrack::Keyframe end = {RawTrackInterpolation::kLinear,
                                                1.f, src_key.value};
      keyframes->push_back(end);
    }
  }
}

template <typename _Keyframes>
void Fixup(_Keyframes* _keyframes) {
  // Nothing to do by default.
  (void)_keyframes;
}
}  // namespace

// Ensures _input's validity and allocates _animation.
// An animation needs to have at least two key frames per joint, the first at
// t = 0 and the last at t = 1. If at least one of those keys are not
// in the RawAnimation then the builder creates it.
template <typename _RawTrack, typename _Track>
unique_ptr<_Track> TrackBuilder::Build(const _RawTrack& _input) const {
  // Tests _raw_animation validity.
  if (!_input.Validate()) {
    return unique_ptr<_Track>();
  }

  // Everything is fine, allocates and fills the animation.
  // Nothing can fail now.
  unique_ptr<_Track> track = make_unique<_Track>();

  // Copy data to temporary prepared data structure
  typename _RawTrack::Keyframes keyframes;
  // Guessing a worst size to avoid realloc.
  const size_t worst_size =
      _input.keyframes.size() * 2 +  // * 2 in case all keys are kStep
      2;                             // + 2 for first and last keys
  keyframes.reserve(worst_size);

  // Ensure there's a key frame at the start and end of the track (required for
  // sampling).
  PatchBeginEndKeys(_input, &keyframes);

  // Fixup values, ex: successive opposite quaternions that would fail to take
  // the shortest path during the normalized-lerp.
  Fixup(&keyframes);

  // Allocates output track.
  const size_t name_len = _input.name.size();
  track->Allocate(keyframes.size(), _input.name.size());

  // Copy all keys to output.
  assert(keyframes.size() == track->ratios_.size() &&
         keyframes.size() == track->values_.size() &&
         keyframes.size() <= track->steps_.size() * 8);
  memset(track->steps_.data(), 0, track->steps_.size_bytes());
  for (size_t i = 0; i < keyframes.size(); ++i) {
    const typename _RawTrack::Keyframe& src_key = keyframes[i];
    track->ratios_[i] = src_key.ratio;
    track->values_[i] = src_key.value;
    track->steps_[i / 8] |=
        (src_key.interpolation == RawTrackInterpolation::kStep) << (i & 7);
  }

  // Copy track's name.
  if (name_len) {
    strcpy(track->name_, _input.name.c_str());
  }

  return track;  // Success.
}

unique_ptr<FloatTrack> TrackBuilder::operator()(
    const RawFloatTrack& _input) const {
  return Build<RawFloatTrack, FloatTrack>(_input);
}
unique_ptr<Float2Track> TrackBuilder::operator()(
    const RawFloat2Track& _input) const {
  return Build<RawFloat2Track, Float2Track>(_input);
}
unique_ptr<Float3Track> TrackBuilder::operator()(
    const RawFloat3Track& _input) const {
  return Build<RawFloat3Track, Float3Track>(_input);
}
unique_ptr<Float4Track> TrackBuilder::operator()(
    const RawFloat4Track& _input) const {
  return Build<RawFloat4Track, Float4Track>(_input);
}

namespace {
// Fixes-up successive opposite quaternions that would fail to take the shortest
// path during the lerp.
template <>
void Fixup<RawQuaternionTrack::Keyframes>(
    RawQuaternionTrack::Keyframes* _keyframes) {
  assert(_keyframes->size() >= 2);

  const math::Quaternion identity = math::Quaternion::identity();
  for (size_t i = 0; i < _keyframes->size(); ++i) {
    RawQuaternionTrack::ValueType& src_key = _keyframes->at(i).value;

    // Normalizes input quaternion.
    src_key = NormalizeSafe(src_key, identity);

    // Ensures quaternions are all on the same hemisphere.
    if (i == 0) {
      if (src_key.w < 0.f) {
        src_key = -src_key;  // Q an -Q are the same rotation.
      }
    } else {
      RawQuaternionTrack::ValueType& prev_key = _keyframes->at(i - 1).value;
      const float dot = src_key.x * prev_key.x + src_key.y * prev_key.y +
                        src_key.z * prev_key.z + src_key.w * prev_key.w;
      if (dot < 0.f) {
        src_key = -src_key;  // Q an -Q are the same rotation.
      }
    }
  }
}
}  // namespace

unique_ptr<QuaternionTrack> TrackBuilder::operator()(
    const RawQuaternionTrack& _input) const {
  return Build<RawQuaternionTrack, QuaternionTrack>(_input);
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including track_optimizer.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/track_optimizer.h"

#include <cassert>
#include <cstddef>

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/offline/decimate.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_OFFLINE_DECIMATE_H_
#define OZZ_ANIMATION_OFFLINE_DECIMATE_H_

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

#include "ozz/base/containers/stack.h"
#include "ozz/base/containers/vector.h"

#include <cassert>

namespace ozz {
namespace animation {
namespace offline {

// Decimation algorithm based on Ramer-Douglas-Peucker.
// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
// _Track must have std::vector interface.
// Adapter must have the following interface:
// struct Adapter {
//  bool Decimable(const Key&) const;
//  Key Lerp(const Key& _left, const Key& _right, const Key& _ref) const;
//  float Distance(const Key& _a, const Key& _b) const;
// };
template <typename _Track, typename _Adapter>
void Decimate(const _Track& _src, const _Adapter& _adapter, float _tolerance,
              _Track* _dest) {
  // Early out if not enough data.
  if (_src.size() < 2) {
    *_dest = _src;
    return;
  }

  // Stack of segments to process.
  typedef std::pair<size_t, size_t> Segment;
  ozz::stack<Segment> segments;

  // Bit vector of all points to included.
  ozz::vector<bool> included(_src.size(), false);

  // Pushes segment made from first and last points.
  segments.push(Segment(0, _src.size() - 1));
  included[0] = true;
  included[_src.size() - 1] = true;

  // Empties segments stack.
  while (!segments.empty()) {
    // Pops next segment to process.
    const Segment segment = segments.top();
    segments.pop();

    // Looks for the furthest point from the segment.
    float max = -1.f;
    size_t candidate = segment.first;
    typename _Track::const_reference left = _src[segment.first];
    typename _Track::const_reference right = _src[segment.second];
    for (size_t i = segment.first + 1; i < segment.second; ++i) {
      assert(!included[i] && "Included points should be processed once only.");
      typename _Track::const_reference test = _src[i];
      if (!_adapter.Decimable(test)) {
        candidate = i;
        break;
      } else {
        const float distance =
            _adapter.Distance(_adapter.Lerp(left, right, test), test);
        if (distance > _tolerance && distance > max) {
          max = distance;
          candidate = i;
        }
      }
    }

    // If found, include the point and pushes the 2 new segments (before and
    // after the new point).
    if (candidate != segment.first) {
      included[candidate] = true;
      if (candidate - segment.first > 1) {
        segments.push(Segment(segment.first, candidate));
      }
      if (segment.second - candidate > 1) {
        segments.push(Segment(candidate, segment.second));
      }
    }
  }

  // Copy all included points.
  _dest->clear();
  for (size_t i = 0; i < _src.size(); ++i) {
    if (included[i]) {
      _dest->push_back(_src[i]);
    }
  }

  // Removes last key if constant.
  if (_dest->size() > 1) {
    typename _Track::const_iterator end = _dest->end();
    typename _Track::const_reference last = *(--end);
    typename _Track::const_reference penultimate = *(--end);
    const float distance = _adapter.Distance(penultimate, last);
    if (_adapter.Decimable(last) && distance <= _tolerance) {
      _dest->pop_back();
    }
  }
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_OFFLINE_DECIMATE_H_


#include "ozz/base/maths/math_ex.h"

#include "ozz/animation/offline/raw_track.h"

// Needs runtime track to access TrackPolicy.
#include "ozz/animation/runtime/track.h"

namespace ozz {
namespace animation {
namespace offline {

// Setup default values (favoring quality).
TrackOptimizer::TrackOptimizer() : tolerance(1e-3f) {  // 1 mm.
}

namespace {

template <typename _KeyFrame>
struct Adapter {
  typedef typename _KeyFrame::ValueType ValueType;
  typedef typename animation::internal::TrackPolicy<ValueType> Policy;

  Adapter() {}

  bool Decimable(const _KeyFrame& _key) const {
    // RawTrackInterpolation::kStep keyframes aren't optimized, as steps can't
    // be interpolated.
    return _key.interpolation != RawTrackInterpolation::kStep;
  }

  _KeyFrame Lerp(const _KeyFrame& _left, const _KeyFrame& _right,
                 const _KeyFrame& _ref) const {
    assert(Decimable(_ref));
    const float alpha =
        (_ref.ratio - _left.ratio) / (_right.ratio - _left.ratio);
    assert(alpha >= 0.f && alpha <= 1.f);
    const _KeyFrame key = {_ref.interpolation, _ref.ratio,
                           Policy::Lerp(_left.value, _right.value, alpha)};
    return key;
  }

  float Distance(const _KeyFrame& _a, const _KeyFrame& _b) const {
    return Policy::Distance(_a.value, _b.value);
  }
};

template <typename _Track>
inline bool Optimize(float _tolerance, const _Track& _input, _Track* _output) {
  if (!_output) {
    return false;
  }
  // Reset output animation to default.
  *_output = _Track();

  // Validate animation.
  if (!_input.Validate()) {
    return false;
  }

  // Copy name
  _output->name = _input.name;

  // Optimizes.
  const Adapter<typename _Track::Keyframe> adapter;
  Decimate(_input.keyframes, adapter, _tolerance, &_output->keyframes);

  // Output animation is always valid though.
  return _output->Validate();
}
}  // namespace

bool TrackOptimizer::operator()(const RawFloatTrack& _input,
                                RawFloatTrack* _output) const {
  return Optimize(tolerance, _input, _output);
}
bool TrackOptimizer::operator()(const RawFloat2Track& _input,
                                RawFloat2Track* _output) const {
  return Optimize(tolerance, _input, _output);
}
bool TrackOptimizer::operator()(const RawFloat3Track& _input,
                                RawFloat3Track* _output) const {
  return Optimize(tolerance, _input, _output);
}
bool TrackOptimizer::operator()(const RawFloat4Track& _input,
                                RawFloat4Track* _output) const {
  return Optimize(tolerance, _input, _output);
}
bool TrackOptimizer::operator()(const RawQuaternionTrack& _input,
                                RawQuaternionTrack* _output) const {
  return Optimize(1.f - std::cos(.5f * tolerance), _input, _output);
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

