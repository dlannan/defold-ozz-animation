// This file is autogenerated. Any modification might be lost.

// Including animation.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/animation.h"

#include <cassert>
#include <cstring>
#include <limits>

#include "ozz/base/io/archive.h"
#include "ozz/base/log.h"
#include "ozz/base/maths/math_archive.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/memory/allocator.h"

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#include "ozz/animation/runtime/export.h"
#include "ozz/base/platform.h"

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {
namespace internal {

// Offset to previous keyframes are stored on uint16_t.
enum Constants { kMaxPreviousOffset = (1 << 16) - 1 };

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time ratio and it's track index. This is
// required as key frames are not sorted per track, but sorted by ratio to favor
// cache coherency. Key frame values are compressed, according on their type.
// Decompression is efficient because it's done on SoA data and cached during
// sampling.

// Defines the float3 key frame type, used for translations and scales.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct OZZ_ANIMATION_DLL Float3Key {
  uint16_t values[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [-1:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
struct QuaternionKey {
  // 2b for the largest component index of the quaternion.
  // 1b for the sign of the largest component. 1 for negative.
  // 15b for each component
  uint16_t values[3];

  // Quantization scale, depends on number of bits.
  static constexpr int kBits = 15;
  static constexpr int kiScale = (1 << kBits) - 1;
  static constexpr float kfScale = 1.f * kiScale;
};

// Endianness independent load and store
inline void pack(int _largest, int _sign, const int _cpnt[3],
                 QuaternionKey* _key) {
  const uint64_t packed =
      (_largest & 0x3) | ((_sign & 0x1) << 2) | (_cpnt[0] & 0x7fff) << 3 |
      uint64_t(_cpnt[1] & 0x7fff) << 18 | (uint64_t(_cpnt[2]) & 0x7fff) << 33;
  _key->values[0] = packed & 0xffff;
  _key->values[1] = (packed >> 16) & 0xffff;
  _key->values[2] = (packed >> 32) & 0xffff;
}

inline void unpack(const QuaternionKey& _key, int& _biggest, int& _sign,
                   int _cpnt[3]) {
  const uint32_t packed = uint32_t(_key.values[0]) >> 3 |
                          uint32_t(_key.values[1]) << 13 |
                          uint32_t(_key.values[2]) << 29;
  _biggest = _key.values[0] & 0x3;
  _sign = (_key.values[0] >> 2) & 0x1;
  _cpnt[0] = packed & 0x7fff;
  _cpnt[1] = (packed >> 15) & 0x7fff;
  _cpnt[2] = _key.values[2] >> 1;
}

}  // namespace internal
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {

Animation::Animation() : duration_(0.f), num_tracks_(0), name_(nullptr) {}

Animation::Animation(Animation&& _other) { *this = std::move(_other); }

Animation& Animation::operator=(Animation&& _other) {
  std::swap(duration_, _other.duration_);
  std::swap(num_tracks_, _other.num_tracks_);
  std::swap(name_, _other.name_);
  std::swap(timepoints_,_other.timepoints_);
  std::swap(translations_ctrl_, _other.translations_ctrl_);
  std::swap(rotations_ctrl_, _other.rotations_ctrl_);
  std::swap(scales_ctrl_, _other.scales_ctrl_);
  std::swap(translations_values_, _other.translations_values_);
  std::swap(rotations_values_, _other.rotations_values_);
  std::swap(scales_values_, _other.scales_values_);

  return *this;
}

Animation::~Animation() { Deallocate(); }

void Animation::Allocate(const AllocateParams& _params) {
  // Distributes buffer memory while ensuring proper alignment (serves larger
  // alignment values first).
  static_assert(
      alignof(float) >= alignof(uint32_t) &&
          alignof(uint32_t) >= alignof(uint16_t) &&
          alignof(uint16_t) >= alignof(internal::Float3Key) &&
          alignof(internal::Float3Key) >= alignof(internal::QuaternionKey) &&
          alignof(internal::QuaternionKey) >= alignof(char),
      "Must serve larger alignment values first)");

  assert(timepoints_.empty() && "Animation must be unallocated");

  // Compute overall size and allocate a single buffer for all the data.
  assert(_params.timepoints <= std::numeric_limits<uint16_t>::max());
  const size_t sizeof_ratio =
      _params.timepoints <= std::numeric_limits<uint8_t>::max()
          ? sizeof(uint8_t)
          : sizeof(uint16_t);
  const size_t sizeof_previous = sizeof(uint16_t);
  const size_t buffer_size =
      (_params.name_len > 0 ? _params.name_len + 1 : 0) +
      _params.timepoints * sizeof(float) +
      _params.translations *
          (sizeof(internal::Float3Key) + sizeof_ratio + sizeof_previous) +
      _params.rotations *
          (sizeof(internal::QuaternionKey) + sizeof_ratio + sizeof_previous) +
      _params.scales *
          (sizeof(internal::Float3Key) + sizeof_ratio + sizeof_previous) +
      _params.translation_iframes.entries * sizeof(byte) +
      _params.translation_iframes.offsets * sizeof(uint32_t) +
      _params.rotation_iframes.entries * sizeof(byte) +
      _params.rotation_iframes.offsets * sizeof(uint32_t) +
      _params.scale_iframes.entries * sizeof(byte) +
      _params.scale_iframes.offsets * sizeof(uint32_t);
  span<byte> buffer = {static_cast<byte*>(memory::default_allocator()->Allocate(
                           buffer_size, alignof(float))),
                       buffer_size};

  // Fix up pointers. Serves larger alignment values first.

  // 32b alignment
  timepoints_ = fill_span<float>(buffer, _params.timepoints);
  translations_ctrl_.iframe_desc =
      fill_span<uint32_t>(buffer, _params.translation_iframes.offsets);
  rotations_ctrl_.iframe_desc =
      fill_span<uint32_t>(buffer, _params.rotation_iframes.offsets);
  scales_ctrl_.iframe_desc =
      fill_span<uint32_t>(buffer, _params.scale_iframes.offsets);

  // 16b alignment
  translations_ctrl_.previouses =
      fill_span<uint16_t>(buffer, _params.translations);
  rotations_ctrl_.previouses = fill_span<uint16_t>(buffer, _params.rotations);
  scales_ctrl_.previouses = fill_span<uint16_t>(buffer, _params.scales);
  translations_values_ =
      fill_span<internal::Float3Key>(buffer, _params.translations);
  rotations_values_ =
      fill_span<internal::QuaternionKey>(buffer, _params.rotations);
  scales_values_ = fill_span<internal::Float3Key>(buffer, _params.scales);

  // 16b / 8b alignment
  translations_ctrl_.ratios =
      fill_span<byte>(buffer, _params.translations * sizeof_ratio);
  rotations_ctrl_.ratios =
      fill_span<byte>(buffer, _params.rotations * sizeof_ratio);
  scales_ctrl_.ratios = fill_span<byte>(buffer, _params.scales * sizeof_ratio);

  // 8b alignment

  // iframe_entries are compressed with gv4, they must not be at the end of the
  // buffer, as gv4 will access 3 bytes further than compressed entries.
  translations_ctrl_.iframe_entries =
      fill_span<byte>(buffer, _params.translation_iframes.entries);
  rotations_ctrl_.iframe_entries =
      fill_span<byte>(buffer, _params.rotation_iframes.entries);
  scales_ctrl_.iframe_entries =
      fill_span<byte>(buffer, _params.scale_iframes.entries);

  // Let name be nullptr if animation has no name. Allows to avoid allocating
  // this buffer in the constructor of empty animations.
  name_ = _params.name_len > 0
              ? fill_span<char>(buffer, _params.name_len + 1).data()
              : nullptr;

  assert(buffer.empty() && "Whole buffer should be consumned");
}

void Animation::Deallocate() {
  memory::default_allocator()->Deallocate(
      as_writable_bytes(timepoints_).data());

  name_ = nullptr;
  timepoints_ = {};
  translations_ctrl_ = {};
  rotations_ctrl_ = {};
  scales_ctrl_ = {};
  translations_values_ = {};
  rotations_values_ = {};
  scales_values_ = {};
}

size_t Animation::size() const {
  const size_t size =
      sizeof(*this) + timepoints_.size_bytes() +
      translations_ctrl_.size_bytes() + rotations_ctrl_.size_bytes() +
      scales_ctrl_.size_bytes() + translations_values_.size_bytes() +
      rotations_values_.size_bytes() + scales_values_.size_bytes();
  return size;
}
}  // namespace animation

namespace io {
OZZ_IO_TYPE_NOT_VERSIONABLE(animation::Animation::KeyframesCtrl)
template <>
struct Extern<animation::Animation::KeyframesCtrl> {
  static void Save(OArchive& _archive,
                   const animation::Animation::KeyframesCtrl* _components,
                   size_t _count) {
    for (size_t i = 0; i < _count; ++i) {
      const animation::Animation::KeyframesCtrl& component = _components[i];
      _archive << ozz::io::MakeArray(component.ratios);
      _archive << ozz::io::MakeArray(component.previouses);
      _archive << ozz::io::MakeArray(component.iframe_entries);
      _archive << ozz::io::MakeArray(component.iframe_desc);
      _archive << component.iframe_interval;
    }
  }
  static void Load(IArchive& _archive,
                   animation::Animation::KeyframesCtrl* _components,
                   size_t _count, uint32_t _version) {
    (void)_version;
    for (size_t i = 0; i < _count; ++i) {
      animation::Animation::KeyframesCtrl& component = _components[i];
      _archive >> ozz::io::MakeArray(component.ratios);
      _archive >> ozz::io::MakeArray(component.previouses);
      _archive >> ozz::io::MakeArray(component.iframe_entries);
      _archive >> ozz::io::MakeArray(component.iframe_desc);
      _archive >> component.iframe_interval;
    }
  }
};

OZZ_IO_TYPE_NOT_VERSIONABLE(animation::internal::Float3Key)
template <>
struct Extern<animation::internal::Float3Key> {
  static void Save(OArchive& _archive,
                   const animation::internal::Float3Key* _keys, size_t _count) {
    _archive << ozz::io::MakeArray(_keys->values,
                                   OZZ_ARRAY_SIZE(_keys->values) * _count);
  }
  static void Load(IArchive& _archive, animation::internal::Float3Key* _keys,
                   size_t _count, uint32_t _version) {
    (void)_version;
    _archive >> ozz::io::MakeArray(_keys->values,
                                   OZZ_ARRAY_SIZE(_keys->values) * _count);
  }
};
OZZ_IO_TYPE_NOT_VERSIONABLE(animation::internal::QuaternionKey)
template <>
struct Extern<animation::internal::QuaternionKey> {
  static void Save(OArchive& _archive,
                   const animation::internal::QuaternionKey* _keys,
                   size_t _count) {
    _archive << ozz::io::MakeArray(_keys->values,
                                   OZZ_ARRAY_SIZE(_keys->values) * _count);
  }
  static void Load(IArchive& _archive,
                   animation::internal::QuaternionKey* _keys, size_t _count,
                   uint32_t _version) {
    (void)_version;
    _archive >> ozz::io::MakeArray(_keys->values,
                                   OZZ_ARRAY_SIZE(_keys->values) * _count);
  }
};
}  // namespace io
namespace animation {
void Animation::Save(ozz::io::OArchive& _archive) const {
  _archive << duration_;
  _archive << static_cast<uint32_t>(num_tracks_);

  const size_t name_len = name_ ? std::strlen(name_) : 0;
  _archive << static_cast<uint32_t>(name_len);

  const size_t timepoints_count = timepoints_.size();
  _archive << static_cast<uint32_t>(timepoints_count);
  const size_t translation_count = translations_values_.size();
  _archive << static_cast<uint32_t>(translation_count);
  const size_t rotation_count = rotations_values_.size();
  _archive << static_cast<uint32_t>(rotation_count);
  const size_t scale_count = scales_values_.size();
  _archive << static_cast<uint32_t>(scale_count);
  const size_t t_iframe_entries_count =
      translations_ctrl_.iframe_entries.size();
  _archive << static_cast<uint32_t>(t_iframe_entries_count);
  const size_t t_iframe_desc_count = translations_ctrl_.iframe_desc.size();
  _archive << static_cast<uint32_t>(t_iframe_desc_count);
  const size_t r_iframe_entries_count = rotations_ctrl_.iframe_entries.size();
  _archive << static_cast<uint32_t>(r_iframe_entries_count);
  const size_t r_iframe_desc_count = rotations_ctrl_.iframe_desc.size();
  _archive << static_cast<uint32_t>(r_iframe_desc_count);
  const size_t s_iframe_entries_count = scales_ctrl_.iframe_entries.size();
  _archive << static_cast<uint32_t>(s_iframe_entries_count);
  const size_t s_iframe_desc_count = scales_ctrl_.iframe_desc.size();
  _archive << static_cast<uint32_t>(s_iframe_desc_count);

  _archive << ozz::io::MakeArray(name_, name_len);
  _archive << ozz::io::MakeArray(timepoints_);

  _archive << translations_ctrl_;
  _archive << io::MakeArray(translations_values_);
  _archive << rotations_ctrl_;
  _archive << io::MakeArray(rotations_values_);
  _archive << scales_ctrl_;
  _archive << io::MakeArray(scales_values_);
}

void Animation::Load(ozz::io::IArchive& _archive, uint32_t _version) {
  // Destroy animation in case it was already used before.
  Deallocate();
  duration_ = 0.f;
  num_tracks_ = 0;

  // No retro-compatibility with anterior versions.
  if (_version != 7) {
    log::Err() << "Unsupported animation version " << _version << "."
               << std::endl;
    return;
  }

  _archive >> duration_;

  uint32_t num_tracks;
  _archive >> num_tracks;
  num_tracks_ = num_tracks;

  uint32_t name_len;
  _archive >> name_len;
  uint32_t timepoints_count;
  _archive >> timepoints_count;
  uint32_t translation_count;
  _archive >> translation_count;
  uint32_t rotation_count;
  _archive >> rotation_count;
  uint32_t scale_count;
  _archive >> scale_count;
  uint32_t t_iframe_entries_count;
  _archive >> t_iframe_entries_count;
  uint32_t t_iframe_desc_count;
  _archive >> t_iframe_desc_count;
  uint32_t r_iframe_entries_count;
  _archive >> r_iframe_entries_count;
  uint32_t r_iframe_desc_count;
  _archive >> r_iframe_desc_count;
  uint32_t s_iframe_entries_count;
  _archive >> s_iframe_entries_count;
  uint32_t s_iframe_desc_count;
  _archive >> s_iframe_desc_count;

  const AllocateParams params{name_len,
                              timepoints_count,
                              translation_count,
                              rotation_count,
                              scale_count,
                              {t_iframe_entries_count, t_iframe_desc_count},
                              {r_iframe_entries_count, r_iframe_desc_count},
                              {s_iframe_entries_count, s_iframe_desc_count}};
  Allocate(params);

  if (name_) {  // nullptr name_ is supported.
    _archive >> ozz::io::MakeArray(name_, name_len);
    name_[name_len] = 0;
  }

  _archive >> ozz::io::MakeArray(timepoints_);

  _archive >> translations_ctrl_;
  _archive >> io::MakeArray(translations_values_);
  _archive >> rotations_ctrl_;
  _archive >> io::MakeArray(rotations_values_);
  _archive >> scales_ctrl_;
  _archive >> io::MakeArray(scales_values_);
}
}  // namespace animation
}  // namespace ozz

// Including animation_utils.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/animation_utils.h"

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#include "ozz/animation/runtime/export.h"
#include "ozz/base/platform.h"

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {
namespace internal {

// Offset to previous keyframes are stored on uint16_t.
enum Constants { kMaxPreviousOffset = (1 << 16) - 1 };

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time ratio and it's track index. This is
// required as key frames are not sorted per track, but sorted by ratio to favor
// cache coherency. Key frame values are compressed, according on their type.
// Decompression is efficient because it's done on SoA data and cached during
// sampling.

// Defines the float3 key frame type, used for translations and scales.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct OZZ_ANIMATION_DLL Float3Key {
  uint16_t values[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [-1:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
struct QuaternionKey {
  // 2b for the largest component index of the quaternion.
  // 1b for the sign of the largest component. 1 for negative.
  // 15b for each component
  uint16_t values[3];

  // Quantization scale, depends on number of bits.
  static constexpr int kBits = 15;
  static constexpr int kiScale = (1 << kBits) - 1;
  static constexpr float kfScale = 1.f * kiScale;
};

// Endianness independent load and store
inline void pack(int _largest, int _sign, const int _cpnt[3],
                 QuaternionKey* _key) {
  const uint64_t packed =
      (_largest & 0x3) | ((_sign & 0x1) << 2) | (_cpnt[0] & 0x7fff) << 3 |
      uint64_t(_cpnt[1] & 0x7fff) << 18 | (uint64_t(_cpnt[2]) & 0x7fff) << 33;
  _key->values[0] = packed & 0xffff;
  _key->values[1] = (packed >> 16) & 0xffff;
  _key->values[2] = (packed >> 32) & 0xffff;
}

inline void unpack(const QuaternionKey& _key, int& _biggest, int& _sign,
                   int _cpnt[3]) {
  const uint32_t packed = uint32_t(_key.values[0]) >> 3 |
                          uint32_t(_key.values[1]) << 13 |
                          uint32_t(_key.values[2]) << 29;
  _biggest = _key.values[0] & 0x3;
  _sign = (_key.values[0] >> 2) & 0x1;
  _cpnt[0] = packed & 0x7fff;
  _cpnt[1] = (packed >> 15) & 0x7fff;
  _cpnt[2] = _key.values[2] >> 1;
}

}  // namespace internal
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {

inline int CountKeyframesImpl(const Animation::KeyframesCtrlConst& _ctrl,
                              int _track) {
  if (_track < 0) {
    return static_cast<int>(_ctrl.previouses.size());
  }

  int count = 1;
  size_t previous = static_cast<size_t>(_track);
  for (size_t i = previous + 1; i < _ctrl.previouses.size(); ++i) {
    if (i - _ctrl.previouses[i] == previous) {
      ++count;
      previous = i;
    }
  }
  return count;
}

int CountTranslationKeyframes(const Animation& _animation, int _track) {
  return CountKeyframesImpl(_animation.translations_ctrl(), _track);
}
int CountRotationKeyframes(const Animation& _animation, int _track) {
  return CountKeyframesImpl(_animation.rotations_ctrl(), _track);
}
int CountScaleKeyframes(const Animation& _animation, int _track) {
  return CountKeyframesImpl(_animation.scales_ctrl(), _track);
}
}  // namespace animation
}  // namespace ozz

// Including blending_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/blending_job.h"

#include <cassert>
#include <cstddef>

#include "ozz/animation/runtime/skeleton.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/soa_transform.h"

namespace ozz {
namespace animation {

BlendingJob::Layer::Layer() : weight(0.f) {}

BlendingJob::BlendingJob() : threshold(.1f) {}

namespace {
bool ValidateLayer(const BlendingJob::Layer& _layer, size_t _min_range) {
  bool valid = true;

  // Tests transforms validity.
  valid &= _layer.transform.size() >= _min_range;

  // Joint weights are optional.
  if (!_layer.joint_weights.empty()) {
    valid &= _layer.joint_weights.size() >= _min_range;
  } else {
    valid &= _layer.joint_weights.empty();
  }
  return valid;
}
}  // namespace

bool BlendingJob::Validate() const {
  // Don't need any early out, as jobs are valid in most of the performance
  // critical cases.
  // Tests are written in multiple lines in order to avoid branches.
  bool valid = true;

  // Test for valid threshold).
  valid &= threshold > 0.f;

  // Test for nullptr begin pointers.
  // Blending layers are mandatory, additive aren't.
  valid &= !rest_pose.empty();
  valid &= !output.empty();

  // The rest pose size defines the ranges of transforms to blend, so all
  // other buffers should be bigger.
  const size_t min_range = rest_pose.size();
  valid &= output.size() >= min_range;

  // Validates layers.
  for (const Layer& layer : layers) {
    valid &= ValidateLayer(layer, min_range);
  }

  // Validates additive layers.
  for (const Layer& layer : additive_layers) {
    valid &= ValidateLayer(layer, min_range);
  }

  return valid;
}

namespace {

// Macro that defines the process of blending the 1st pass.
#define OZZ_BLEND_1ST_PASS(_in, _simd_weight, _out)    \
  do {                                                 \
    _out.translation = _in.translation * _simd_weight; \
    _out.rotation = _in.rotation * _simd_weight;       \
    _out.scale = _in.scale * _simd_weight;             \
  } while (void(0), 0)

// Macro that defines the process of blending any pass but the first.
#define OZZ_BLEND_N_PASS(_in, _simd_weight, _out)                             \
  do {                                                                        \
    /* Blends translation. */                                                 \
    _out.translation = _out.translation + _in.translation * _simd_weight;     \
    /* Blends rotations, negates opposed quaternions to be sure to choose*/   \
    /* the shortest path between the two.*/                                   \
    const math::SimdInt4 sign = math::Sign(Dot(_out.rotation, _in.rotation)); \
    const math::SoaQuaternion rotation = {                                    \
        math::Xor(_in.rotation.x, sign), math::Xor(_in.rotation.y, sign),     \
        math::Xor(_in.rotation.z, sign), math::Xor(_in.rotation.w, sign)};    \
    _out.rotation = _out.rotation + rotation * _simd_weight;                  \
    /* Blends scales.*/                                                       \
    _out.scale = _out.scale + _in.scale * _simd_weight;                       \
  } while (void(0), 0)

// Macro that defines the process of adding a pass.
#define OZZ_ADD_PASS(_in, _simd_weight, _out)                               \
  do {                                                                      \
    _out.translation = _out.translation + _in.translation * _simd_weight;   \
    /* Interpolate quaternion between identity and src.rotation.*/          \
    /* Quaternion sign is fixed up, so that lerp takes the shortest path.*/ \
    const math::SimdInt4 sign = math::Sign(_in.rotation.w);                 \
    const math::SoaQuaternion interp_quat = {                               \
        math::Xor(_in.rotation.x, sign) * _simd_weight,                     \
        math::Xor(_in.rotation.y, sign) * _simd_weight,                     \
        math::Xor(_in.rotation.z, sign) * _simd_weight,                     \
        (math::Xor(_in.rotation.w, sign) - one) * _simd_weight + one};      \
    _out.rotation = _out.rotation * NormalizeEst(interp_quat);              \
    _out.scale.x = _out.scale.x *                                           \
                   math::MAdd(_in.scale.x, _simd_weight, one_minus_weight); \
    _out.scale.y = _out.scale.y *                                           \
                   math::MAdd(_in.scale.y, _simd_weight, one_minus_weight); \
    _out.scale.z = _out.scale.z *                                           \
                   math::MAdd(_in.scale.z, _simd_weight, one_minus_weight); \
  } while (void(0), 0)

// Macro that defines the process of subtracting a pass.
#define OZZ_SUB_PASS(_in, _simd_weight, _out)                                  \
  do {                                                                         \
    _out.translation = _out.translation - _in.translation * _simd_weight;      \
    /* Interpolate quaternion between identity and src.rotation.*/             \
    /* Quaternion sign is fixed up, so that lerp takes the shortest path.*/    \
    const math::SimdInt4 sign = math::Sign(_in.rotation.w);                    \
    const math::SoaQuaternion interp_quat = {                                  \
        math::Xor(_in.rotation.x, sign) * _simd_weight,                        \
        math::Xor(_in.rotation.y, sign) * _simd_weight,                        \
        math::Xor(_in.rotation.z, sign) * _simd_weight,                        \
        (math::Xor(_in.rotation.w, sign) - one) * _simd_weight + one};         \
    _out.rotation = _out.rotation * Conjugate(NormalizeEst(interp_quat));      \
    _out.scale.x =                                                             \
        _out.scale.x *                                                         \
        math::RcpEst(math::MAdd(_in.scale.x, _simd_weight, one_minus_weight)); \
    _out.scale.y =                                                             \
        _out.scale.y *                                                         \
        math::RcpEst(math::MAdd(_in.scale.y, _simd_weight, one_minus_weight)); \
    _out.scale.z =                                                             \
        _out.scale.z *                                                         \
        math::RcpEst(math::MAdd(_in.scale.z, _simd_weight, one_minus_weight)); \
  } while (void(0), 0)

// Defines parameters that are passed through blending stages.
struct ProcessArgs {
  ProcessArgs(const BlendingJob& _job)
      : job(_job),
        num_soa_joints(_job.rest_pose.size()),
        num_passes(0),
        num_partial_passes(0),
        accumulated_weight(0.f) {
    // The range of all buffers has already been validated.
    assert(job.output.size() >= num_soa_joints);
    assert(OZZ_ARRAY_SIZE(accumulated_weights) >= num_soa_joints);
  }

  // Allocates enough space to store a accumulated weights per-joint.
  // It will be initialized by the first pass processed, if any.
  // This is quite big for a stack allocation (4 byte * maximum number of
  // joints). This is one of the reasons why the number of joints is limited
  // by the API.
  // Note that this array is used with SoA data.
  // This is the first argument in order to avoid wasting too much space with
  // alignment padding.
  math::SimdFloat4 accumulated_weights[Skeleton::kMaxSoAJoints];

  // The job to process.
  const BlendingJob& job;

  // The number of transforms to process as defined by the size of the rest
  // pose.
  size_t num_soa_joints;

  // Number of processed blended passes (excluding passes with a weight <= 0.f),
  // including partial passes.
  int num_passes;

  // Number of processed partial blending passes (aka with a weight per-joint).
  int num_partial_passes;

  // The accumulated weight of all layers.
  float accumulated_weight;

 private:
  // Disables assignment operators.
  ProcessArgs(const ProcessArgs&);
  void operator=(const ProcessArgs&);
};

// Blends all layers of the job to its output.
void BlendLayers(ProcessArgs* _args) {
  assert(_args);

  // Iterates through all layers and blend them to the output.
  for (const BlendingJob::Layer& layer : _args->job.layers) {
    // Asserts buffer sizes, which must never fail as it has been validated.
    assert(layer.transform.size() >= _args->num_soa_joints);
    assert(layer.joint_weights.empty() ||
           (layer.joint_weights.size() >= _args->num_soa_joints));

    // Skip irrelevant layers.
    if (layer.weight <= 0.f) {
      continue;
    }

    // Accumulates global weights.
    _args->accumulated_weight += layer.weight;
    const math::SimdFloat4 layer_weight =
        math::simd_float4::Load1(layer.weight);

    if (!layer.joint_weights.empty()) {
      // This layer has per-joint weights.
      ++_args->num_partial_passes;

      if (_args->num_passes == 0) {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer.joint_weights[i]);
          _args->accumulated_weights[i] = weight;
          OZZ_BLEND_1ST_PASS(src, weight, dest);
        }
      } else {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer.joint_weights[i]);
          _args->accumulated_weights[i] =
              _args->accumulated_weights[i] + weight;
          OZZ_BLEND_N_PASS(src, weight, dest);
        }
      }
    } else {
      // This is a full layer.
      if (_args->num_passes == 0) {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          _args->accumulated_weights[i] = layer_weight;
          OZZ_BLEND_1ST_PASS(src, layer_weight, dest);
        }
      } else {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          _args->accumulated_weights[i] =
              _args->accumulated_weights[i] + layer_weight;
          OZZ_BLEND_N_PASS(src, layer_weight, dest);
        }
      }
    }
    // One more pass blended.
    ++_args->num_passes;
  }
}

// Blends rest pose to the output if accumulated weight is less than the
// threshold value.
void BlendRestPose(ProcessArgs* _args) {
  assert(_args);

  // Asserts buffer sizes, which must never fail as it has been validated.
  assert(_args->job.rest_pose.size() >= _args->num_soa_joints);

  if (_args->num_partial_passes == 0) {
    // No partial blending pass detected, threshold can be tested globally.
    const float bp_weight = _args->job.threshold - _args->accumulated_weight;

    if (bp_weight > 0.f) {  // The rest-pose is needed if it has a weight.
      if (_args->num_passes == 0) {
        // Strictly copying rest-pose.
        _args->accumulated_weight = 1.f;
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          _args->job.output[i] = _args->job.rest_pose[i];
        }
      } else {
        // Updates global accumulated weight, but not per-joint weight any more
        // because normalization stage will be global also.
        _args->accumulated_weight = _args->job.threshold;

        const math::SimdFloat4 simd_bp_weight =
            math::simd_float4::Load1(bp_weight);

        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = _args->job.rest_pose[i];
          math::SoaTransform& dest = _args->job.output[i];
          OZZ_BLEND_N_PASS(src, simd_bp_weight, dest);
        }
      }
    }
  } else {
    // Blending passes contain partial blending, threshold must be tested for
    // each joint.
    const math::SimdFloat4 threshold =
        math::simd_float4::Load1(_args->job.threshold);

    // There's been at least 1 pass as num_partial_passes != 0.
    assert(_args->num_passes != 0);

    for (size_t i = 0; i < _args->num_soa_joints; ++i) {
      const math::SoaTransform& src = _args->job.rest_pose[i];
      math::SoaTransform& dest = _args->job.output[i];
      const math::SimdFloat4 bp_weight =
          math::Max0(threshold - _args->accumulated_weights[i]);
      _args->accumulated_weights[i] =
          math::Max(threshold, _args->accumulated_weights[i]);
      OZZ_BLEND_N_PASS(src, bp_weight, dest);
    }
  }
}

// Normalizes output rotations. Quaternion length cannot be zero as opposed
// quaternions have been fixed up during blending passes.
// Translations and scales are already normalized because weights were
// pre-multiplied by the normalization ratio.
void Normalize(ProcessArgs* _args) {
  assert(_args);

  if (_args->num_partial_passes == 0) {
    // Normalization of a non-partial blending requires to apply the same
    // division to all joints.
    const math::SimdFloat4 ratio =
        math::simd_float4::Load1(1.f / _args->accumulated_weight);
    for (size_t i = 0; i < _args->num_soa_joints; ++i) {
      math::SoaTransform& dest = _args->job.output[i];
      dest.rotation = NormalizeEst(dest.rotation);
      dest.translation = dest.translation * ratio;
      dest.scale = dest.scale * ratio;
    }
  } else {
    // Partial blending normalization requires to compute the divider per-joint.
    const math::SimdFloat4 one = math::simd_float4::one();
    for (size_t i = 0; i < _args->num_soa_joints; ++i) {
      const math::SimdFloat4 ratio = one / _args->accumulated_weights[i];
      math::SoaTransform& dest = _args->job.output[i];
      dest.rotation = NormalizeEst(dest.rotation);
      dest.translation = dest.translation * ratio;
      dest.scale = dest.scale * ratio;
    }
  }
}

// Process additive blending pass.
void AddLayers(ProcessArgs* _args) {
  assert(_args);

  // Iterates through all layers and blend them to the output.
  for (const BlendingJob::Layer& layer : _args->job.additive_layers) {
    // Asserts buffer sizes, which must never fail as it has been validated.
    assert(layer.transform.size() >= _args->num_soa_joints);
    assert(layer.joint_weights.empty() ||
           (layer.joint_weights.size() >= _args->num_soa_joints));

    // Prepares constants.
    const math::SimdFloat4 one = math::simd_float4::one();

    if (layer.weight > 0.f) {
      // Weight is positive, need to perform additive blending.
      const math::SimdFloat4 layer_weight =
          math::simd_float4::Load1(layer.weight);

      if (!layer.joint_weights.empty()) {
        // This layer has per-joint weights.
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer.joint_weights[i]);
          const math::SimdFloat4 one_minus_weight = one - weight;
          OZZ_ADD_PASS(src, weight, dest);
        }
      } else {
        // This is a full layer.
        const math::SimdFloat4 one_minus_weight = one - layer_weight;

        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          OZZ_ADD_PASS(src, layer_weight, dest);
        }
      }
    } else if (layer.weight < 0.f) {
      // Weight is negative, need to perform subtractive blending.
      const math::SimdFloat4 layer_weight =
          math::simd_float4::Load1(-layer.weight);

      if (!layer.joint_weights.empty()) {
        // This layer has per-joint weights.
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer.joint_weights[i]);
          const math::SimdFloat4 one_minus_weight = one - weight;
          OZZ_SUB_PASS(src, weight, dest);
        }
      } else {
        // This is a full layer.
        const math::SimdFloat4 one_minus_weight = one - layer_weight;
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer.transform[i];
          math::SoaTransform& dest = _args->job.output[i];
          OZZ_SUB_PASS(src, layer_weight, dest);
        }
      }
    } else {
      // Skip layer as its weight is 0.
    }
  }
}
}  // namespace

bool BlendingJob::Run() const {
  if (!Validate()) {
    return false;
  }

  // Initializes blended parameters that are exchanged across blend stages.
  ProcessArgs process_args(*this);

  // Blends all layers to the job output buffers.
  BlendLayers(&process_args);

  // Applies rest pose.
  BlendRestPose(&process_args);

  // Normalizes output.
  Normalize(&process_args);

  // Process additive blending.
  AddLayers(&process_args);

  return true;
}
}  // namespace animation
}  // namespace ozz

// Including ik_aim_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/ik_aim_job.h"

#include <cassert>

#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/simd_quaternion.h"

using namespace ozz::math;

namespace ozz {
namespace animation {
IKAimJob::IKAimJob()
    : target(simd_float4::zero()),
      forward(simd_float4::x_axis()),
      offset(simd_float4::zero()),
      up(simd_float4::y_axis()),
      pole_vector(simd_float4::y_axis()),
      twist_angle(0.f),
      weight(1.f),
      joint(nullptr),
      joint_correction(nullptr),
      reached(nullptr) {}

bool IKAimJob::Validate() const {
  bool valid = true;
  valid &= joint != nullptr;
  valid &= joint_correction != nullptr;
  valid &= ozz::math::AreAllTrue1(ozz::math::IsNormalizedEst3(forward));
  return valid;
}

namespace {

// When there's an offset, the forward vector needs to be recomputed.
// The idea is to find the vector that will allow the point at offset position
// to aim at target position. This vector starts at joint position. It ends on a
// line perpendicular to pivot-offset line, at the intersection with the sphere
// defined by target position (centered on joint position). See geogebra
// diagram: media/doc/src/ik_aim_offset.ggb
bool ComputeOffsettedForward(_SimdFloat4 _forward, _SimdFloat4 _offset,
                             _SimdFloat4 _target,
                             SimdFloat4* _offsetted_forward) {
  // AO is projected offset vector onto the normalized forward vector.
  assert(ozz::math::AreAllTrue1(ozz::math::IsNormalizedEst3(_forward)));
  const SimdFloat4 AOl = Dot3(_forward, _offset);

  // Compute square length of ac using Pythagorean theorem.
  const SimdFloat4 ACl2 = Length3Sqr(_offset) - AOl * AOl;

  // Square length of target vector, aka circle radius.
  const SimdFloat4 r2 = Length3Sqr(_target);

  // If offset is outside of the sphere defined by target length, the target
  // isn't reachable.
  if (AreAllTrue1(CmpGt(ACl2, r2))) {
    return false;
  }

  // AIl is the length of the vector from offset to sphere intersection.
  const SimdFloat4 AIl = SqrtX(r2 - ACl2);

  // The distance from offset position to the intersection with the sphere is
  // (AIl - AOl) Intersection point on the sphere can thus be computed.
  *_offsetted_forward = _offset + _forward * SplatX(AIl - AOl);

  return true;
}
}  // namespace

bool IKAimJob::Run() const {
  if (!Validate()) {
    return false;
  }

  using math::Float4x4;
  using math::SimdFloat4;
  using math::SimdQuaternion;

  // If matrices aren't invertible, they'll be all 0 (ozz::math
  // implementation), which will result in identity correction quaternions.
  SimdInt4 invertible;
  const Float4x4 inv_joint = Invert(*joint, &invertible);

  // Computes joint to target vector, in joint local-space (_js).
  const SimdFloat4 joint_to_target_js = TransformPoint(inv_joint, target);
  const SimdFloat4 joint_to_target_js_len2 = Length3Sqr(joint_to_target_js);

  // Recomputes forward vector to account for offset.
  // If the offset is further than target, it won't be reachable.
  SimdFloat4 offsetted_forward;
  bool lreached = ComputeOffsettedForward(forward, offset, joint_to_target_js,
                                          &offsetted_forward);
  // Copies reachability result.
  // If offsetted forward vector doesn't exists, target position cannot be
  // aimed.
  if (reached != nullptr) {
    *reached = lreached;
  }

  if (!lreached ||
      AreAllTrue1(CmpEq(joint_to_target_js_len2, simd_float4::zero()))) {
    // Target can't be reached or is too close to joint position to find a
    // direction.
    *joint_correction = SimdQuaternion::identity();
    return true;
  }

  // Calculates joint_to_target_rot_ss quaternion which solves for
  // offsetted_forward vector rotating onto the target.
  const SimdQuaternion joint_to_target_rot_js =
      SimdQuaternion::FromVectors(offsetted_forward, joint_to_target_js);

  // Calculates rotate_plane_js quaternion which aligns joint up to the pole
  // vector.
  const SimdFloat4 corrected_up_js =
      TransformVector(joint_to_target_rot_js, up);

  // Compute (and normalize) reference and pole planes normals.
  const SimdFloat4 pole_vector_js = TransformVector(inv_joint, pole_vector);
  const SimdFloat4 ref_joint_normal_js =
      Cross3(pole_vector_js, joint_to_target_js);
  const SimdFloat4 joint_normal_js =
      Cross3(corrected_up_js, joint_to_target_js);
  const SimdFloat4 ref_joint_normal_js_len2 = Length3Sqr(ref_joint_normal_js);
  const SimdFloat4 joint_normal_js_len2 = Length3Sqr(joint_normal_js);

  const SimdFloat4 denoms =
      SetZ(SetY(joint_to_target_js_len2, joint_normal_js_len2),
           ref_joint_normal_js_len2);

  SimdFloat4 rotate_plane_axis_js;
  SimdQuaternion rotate_plane_js;
  // Computing rotation axis and plane requires valid normals.
  if (AreAllTrue3(CmpNe(denoms, simd_float4::zero()))) {
    const SimdFloat4 rsqrts =
        RSqrtEstNR(SetZ(SetY(joint_to_target_js_len2, joint_normal_js_len2),
                        ref_joint_normal_js_len2));

    // Computes rotation axis, which is either joint_to_target_js or
    // -joint_to_target_js depending on rotation direction.
    rotate_plane_axis_js = joint_to_target_js * SplatX(rsqrts);

    // Computes angle cosine between the 2 normalized plane normals.
    const SimdFloat4 rotate_plane_cos_angle = Dot3(
        joint_normal_js * SplatY(rsqrts), ref_joint_normal_js * SplatZ(rsqrts));
    const SimdFloat4 axis_flip =
        And(SplatX(Dot3(ref_joint_normal_js, corrected_up_js)),
            simd_int4::mask_sign());
    const SimdFloat4 rotate_plane_axis_flipped_js =
        Xor(rotate_plane_axis_js, axis_flip);

    // Builds quaternion along rotation axis.
    const SimdFloat4 one = simd_float4::one();
    rotate_plane_js = SimdQuaternion::FromAxisCosAngle(
        rotate_plane_axis_flipped_js, Clamp(-one, rotate_plane_cos_angle, one));
  } else {
    rotate_plane_axis_js = joint_to_target_js * SplatX(RSqrtEstXNR(denoms));
    rotate_plane_js = SimdQuaternion::identity();
  }

  // Twists rotation plane.
  SimdQuaternion twisted;
  if (twist_angle != 0.f) {
    // If a twist angle is provided, rotation angle is rotated around joint to
    // target vector.
    const SimdQuaternion twist_ss = SimdQuaternion::FromAxisAngle(
        rotate_plane_axis_js, simd_float4::Load1(twist_angle));
    twisted = twist_ss * rotate_plane_js * joint_to_target_rot_js;
  } else {
    twisted = rotate_plane_js * joint_to_target_rot_js;
  }

  // Weights output quaternion.

  // Fix up quaternions so w is always positive, which is required for NLerp
  // (with identity quaternion) to lerp the shortest path.
  const SimdFloat4 twisted_fu =
      Xor(twisted.xyzw, And(simd_int4::mask_sign(),
                            CmpLt(SplatW(twisted.xyzw), simd_float4::zero())));

  if (weight < 1.f) {
    // NLerp start and mid joint rotations.
    const SimdFloat4 identity = simd_float4::w_axis();
    const SimdFloat4 simd_weight = Max0(simd_float4::Load1(weight));
    joint_correction->xyzw =
        NormalizeEst4(Lerp(identity, twisted.xyzw, simd_weight));
  } else {
    // Quaternion doesn't need interpolation
    joint_correction->xyzw = twisted_fu;
  }

  return true;
}
}  // namespace animation
}  // namespace ozz

// Including ik_two_bone_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/ik_two_bone_job.h"

#include <cassert>

#include "ozz/base/log.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/simd_quaternion.h"

using namespace ozz::math;

namespace ozz {
namespace animation {
IKTwoBoneJob::IKTwoBoneJob()
    : target(math::simd_float4::zero()),
      mid_axis(math::simd_float4::z_axis()),
      pole_vector(math::simd_float4::y_axis()),
      twist_angle(0.f),
      soften(1.f),
      weight(1.f),
      start_joint(nullptr),
      mid_joint(nullptr),
      end_joint(nullptr),
      start_joint_correction(nullptr),
      mid_joint_correction(nullptr),
      reached(nullptr) {}

bool IKTwoBoneJob::Validate() const {
  bool valid = true;
  valid &= start_joint && mid_joint && end_joint;
  valid &= start_joint_correction && mid_joint_correction;
  valid &= ozz::math::AreAllTrue1(ozz::math::IsNormalizedEst3(mid_axis));
  return valid;
}

namespace {

// Local data structure used to share constant data accross ik stages.
struct IKConstantSetup {
  IKConstantSetup(const IKTwoBoneJob& _job) {
    // Prepares constants
    one = simd_float4::one();
    mask_sign = simd_int4::mask_sign();
    m_one = Xor(one, mask_sign);

    // Computes inverse matrices required to change to start and mid spaces.
    // If matrices aren't invertible, they'll be all 0 (ozz::math
    // implementation), which will result in identity correction quaternions.
    SimdInt4 invertible;
    (void)invertible;
    inv_start_joint = Invert(*_job.start_joint, &invertible);
    const Float4x4 inv_mid_joint = Invert(*_job.mid_joint, &invertible);

    // Transform some positions to mid joint space (_ms)
    const SimdFloat4 start_ms =
        TransformPoint(inv_mid_joint, _job.start_joint->cols[3]);
    const SimdFloat4 end_ms =
        TransformPoint(inv_mid_joint, _job.end_joint->cols[3]);

    // Transform some positions to start joint space (_ss)
    const SimdFloat4 mid_ss =
        TransformPoint(inv_start_joint, _job.mid_joint->cols[3]);
    const SimdFloat4 end_ss =
        TransformPoint(inv_start_joint, _job.end_joint->cols[3]);

    // Computes bones vectors and length in mid and start spaces.
    // Start joint position will be treated as 0 because all joints are
    // expressed in start joint space.
    start_mid_ms = -start_ms;
    mid_end_ms = end_ms;
    start_mid_ss = mid_ss;
    const SimdFloat4 mid_end_ss = end_ss - mid_ss;
    const SimdFloat4 start_end_ss = end_ss;
    start_mid_ss_len2 = Length3Sqr(start_mid_ss);
    mid_end_ss_len2 = Length3Sqr(mid_end_ss);
    start_end_ss_len2 = Length3Sqr(start_end_ss);
  }

  // Constants
  SimdFloat4 one;
  SimdFloat4 m_one;
  SimdInt4 mask_sign;

  // Inverse matrices
  Float4x4 inv_start_joint;

  // Bones vectors and length in mid and start spaces (_ms and _ss).
  SimdFloat4 start_mid_ms;
  SimdFloat4 mid_end_ms;
  SimdFloat4 start_mid_ss;
  SimdFloat4 start_mid_ss_len2;
  SimdFloat4 mid_end_ss_len2;
  SimdFloat4 start_end_ss_len2;
};

// Smoothen target position when it's further that a ratio of the joint chain
// length, and start to target length isn't 0.
// Inspired by http://www.softimageblog.com/archives/108
// and http://www.ryanjuckett.com/programming/analytic-two-bone-ik-in-2d/
bool SoftenTarget(const IKTwoBoneJob& _job, const IKConstantSetup& _setup,
                  SimdFloat4* _start_target_ss,
                  SimdFloat4* _start_target_ss_len2) {
  // Hanlde position in start joint space (_ss)
  const SimdFloat4 start_target_original_ss =
      TransformPoint(_setup.inv_start_joint, _job.target);
  const SimdFloat4 start_target_original_ss_len2 =
      Length3Sqr(start_target_original_ss);
  const SimdFloat4 lengths =
      Sqrt(SetZ(SetY(_setup.start_mid_ss_len2, _setup.mid_end_ss_len2),
                start_target_original_ss_len2));
  const SimdFloat4 start_mid_ss_len = lengths;
  const SimdFloat4 mid_end_ss_len = SplatY(lengths);
  const SimdFloat4 start_target_original_ss_len = SplatZ(lengths);
  const SimdFloat4 bone_len_diff_abs =
      AndNot(start_mid_ss_len - mid_end_ss_len, _setup.mask_sign);
  const SimdFloat4 bones_chain_len = start_mid_ss_len + mid_end_ss_len;
  const SimdFloat4 da =  // da.yzw needs to be 0
      bones_chain_len *
      Clamp(simd_float4::zero(), simd_float4::LoadX(_job.soften), _setup.one);
  const SimdFloat4 ds = bones_chain_len - da;

  // Sotftens target position if it is further than a ratio (_soften) of the
  // whole bone chain length. Needs to check also that ds and
  // start_target_original_ss_len2 are != 0, because they're used as a
  // denominator.
  // x = start_target_original_ss_len > da
  // y = start_target_original_ss_len > 0
  // z = start_target_original_ss_len > bone_len_diff_abs
  // w = ds                           > 0
  const SimdFloat4 left = SetW(start_target_original_ss_len, ds);
  const SimdFloat4 right = SetZ(da, bone_len_diff_abs);
  const SimdInt4 comp = CmpGt(left, right);
  const int comp_mask = MoveMask(comp);

  // xyw all 1, z is untested.
  if ((comp_mask & 0xb) == 0xb) {
    // Finds interpolation ratio (aka alpha).
    const SimdFloat4 alpha = (start_target_original_ss_len - da) * RcpEstX(ds);
    // Approximate an exponential function with : 1-(3^4)/(alpha+3)^4
    // The derivative must be 1 for x = 0, and y must never exceeds 1.
    // Negative x aren't used.
    const SimdFloat4 three = simd_float4::Load1(3.f);
    const SimdFloat4 op = SetY(three, alpha + three);
    const SimdFloat4 op2 = op * op;
    const SimdFloat4 op4 = op2 * op2;
    const SimdFloat4 ratio = op4 * RcpEstX(SplatY(op4));

    // Recomputes start_target_ss vector and length.
    const SimdFloat4 start_target_ss_len = da + ds - ds * ratio;
    *_start_target_ss_len2 = start_target_ss_len * start_target_ss_len;
    *_start_target_ss =
        start_target_original_ss *
        SplatX(start_target_ss_len * RcpEstX(start_target_original_ss_len));
  } else {
    *_start_target_ss = start_target_original_ss;
    *_start_target_ss_len2 = start_target_original_ss_len2;
  }

  // The maximum distance we can reach is the soften bone chain length: da
  // (stored in !x). The minimum distance we can reach is the absolute value of
  // the difference of the 2 bone lengths, |d1-d2| (stored in z). x is 0 and z
  // is 1, yw are untested.
  return (comp_mask & 0x5) == 0x4;
}

SimdQuaternion ComputeMidJoint(const IKTwoBoneJob& _job,
                               const IKConstantSetup& _setup,
                               _SimdFloat4 _start_target_ss_len2) {
  // Computes expected angle at mid_ss joint, using law of cosine (generalized
  // Pythagorean).
  // c^2 = a^2 + b^2 - 2ab cosC
  // cosC = (a^2 + b^2 - c^2) / 2ab
  // Computes both corrected and initial mid joint angles
  // cosine within a single SimdFloat4 (corrected is x component, initial is y).
  const SimdFloat4 start_mid_end_sum_ss_len2 =
      _setup.start_mid_ss_len2 + _setup.mid_end_ss_len2;
  const SimdFloat4 start_mid_end_ss_half_rlen =
      SplatX(simd_float4::Load1(.5f) *
             RSqrtEstXNR(_setup.start_mid_ss_len2 * _setup.mid_end_ss_len2));
  // Cos value needs to be clamped, as it will exit expected range if
  // start_target_ss_len2 is longer than the triangle can be (start_mid_ss +
  // mid_end_ss).
  const SimdFloat4 mid_cos_angles_unclamped =
      (SplatX(start_mid_end_sum_ss_len2) -
       SetY(_start_target_ss_len2, _setup.start_end_ss_len2)) *
      start_mid_end_ss_half_rlen;
  const SimdFloat4 mid_cos_angles =
      Clamp(_setup.m_one, mid_cos_angles_unclamped, _setup.one);

  // Computes corrected angle
  const SimdFloat4 mid_corrected_angle = ACosX(mid_cos_angles);

  // Computes initial angle.
  // The sign of this angle needs to be decided. It's considered negative if
  // mid-to-end joint is bent backward (mid_axis direction dictates valid
  // bent direction).
  const SimdFloat4 bent_side_ref = Cross3(_setup.start_mid_ms, _job.mid_axis);
  const SimdInt4 bent_side_flip = SplatX(
      CmpLt(Dot3(bent_side_ref, _setup.mid_end_ms), simd_float4::zero()));
  const SimdFloat4 mid_initial_angle =
      Xor(ACosX(SplatY(mid_cos_angles)), And(bent_side_flip, _setup.mask_sign));

  // Finally deduces initial to corrected angle difference.
  const SimdFloat4 mid_angles_diff = mid_corrected_angle - mid_initial_angle;

  // Builds queternion.
  return SimdQuaternion::FromAxisAngle(_job.mid_axis, mid_angles_diff);
}

SimdQuaternion ComputeStartJoint(const IKTwoBoneJob& _job,
                                 const IKConstantSetup& _setup,
                                 const SimdQuaternion& _mid_rot_ms,
                                 _SimdFloat4 _start_target_ss,
                                 _SimdFloat4 _start_target_ss_len2) {
  // Pole vector in start joint space (_ss)
  const SimdFloat4 pole_ss =
      TransformVector(_setup.inv_start_joint, _job.pole_vector);

  // start_mid_ss with quaternion mid_rot_ms applied.
  const SimdFloat4 mid_end_ss_final = TransformVector(
      _setup.inv_start_joint,
      TransformVector(*_job.mid_joint,
                      TransformVector(_mid_rot_ms, _setup.mid_end_ms)));
  const SimdFloat4 start_end_ss_final = _setup.start_mid_ss + mid_end_ss_final;

  // Quaternion for rotating the effector onto the target
  const SimdQuaternion end_to_target_rot_ss =
      SimdQuaternion::FromVectors(start_end_ss_final, _start_target_ss);

  // Calculates rotate_plane_ss quaternion which aligns joint chain plane to
  // the reference plane (pole vector). This can only be computed if start
  // target axis is valid (not 0 length)
  // -------------------------------------------------
  SimdQuaternion start_rot_ss = end_to_target_rot_ss;
  if (AreAllTrue1(CmpGt(_start_target_ss_len2, simd_float4::zero()))) {
    // Computes each plane normal.
    const ozz::math::SimdFloat4 ref_plane_normal_ss =
        Cross3(_start_target_ss, pole_ss);
    const ozz::math::SimdFloat4 ref_plane_normal_ss_len2 =
        ozz::math::Length3Sqr(ref_plane_normal_ss);
    // Computes joint chain plane normal, which is the same as mid joint axis
    // (same triangle).
    const ozz::math::SimdFloat4 mid_axis_ss =
        TransformVector(_setup.inv_start_joint,
                        TransformVector(*_job.mid_joint, _job.mid_axis));
    const ozz::math::SimdFloat4 joint_plane_normal_ss =
        TransformVector(end_to_target_rot_ss, mid_axis_ss);
    const ozz::math::SimdFloat4 joint_plane_normal_ss_len2 =
        ozz::math::Length3Sqr(joint_plane_normal_ss);
    // Computes all reciprocal square roots at once.
    const SimdFloat4 rsqrts =
        RSqrtEstNR(SetZ(SetY(_start_target_ss_len2, ref_plane_normal_ss_len2),
                        joint_plane_normal_ss_len2));

    // Computes angle cosine between the 2 normalized normals.
    const SimdFloat4 rotate_plane_cos_angle =
        ozz::math::Dot3(ref_plane_normal_ss * SplatY(rsqrts),
                        joint_plane_normal_ss * SplatZ(rsqrts));

    // Computes rotation axis, which is either start_target_ss or
    // -start_target_ss depending on rotation direction.
    const SimdFloat4 rotate_plane_axis_ss = _start_target_ss * SplatX(rsqrts);
    const SimdFloat4 start_axis_flip =
        And(SplatX(Dot3(joint_plane_normal_ss, pole_ss)), _setup.mask_sign);
    const SimdFloat4 rotate_plane_axis_flipped_ss =
        Xor(rotate_plane_axis_ss, start_axis_flip);

    // Builds quaternion along rotation axis.
    const SimdQuaternion rotate_plane_ss = SimdQuaternion::FromAxisCosAngle(
        rotate_plane_axis_flipped_ss,
        Clamp(_setup.m_one, rotate_plane_cos_angle, _setup.one));

    if (_job.twist_angle != 0.f) {
      // If a twist angle is provided, rotation angle is rotated along
      // rotation plane axis.
      const SimdQuaternion twist_ss = SimdQuaternion::FromAxisAngle(
          rotate_plane_axis_ss, simd_float4::Load1(_job.twist_angle));
      start_rot_ss = twist_ss * rotate_plane_ss * end_to_target_rot_ss;
    } else {
      start_rot_ss = rotate_plane_ss * end_to_target_rot_ss;
    }
  }
  return start_rot_ss;
}

void WeightOutput(const IKTwoBoneJob& _job, const IKConstantSetup& _setup,
                  const SimdQuaternion& _start_rot,
                  const SimdQuaternion& _mid_rot) {
  const SimdFloat4 zero = simd_float4::zero();

  // Fix up quaternions so w is always positive, which is required for NLerp
  // (with identity quaternion) to lerp the shortest path.
  const SimdFloat4 start_rot_fu =
      Xor(_start_rot.xyzw,
          And(_setup.mask_sign, CmpLt(SplatW(_start_rot.xyzw), zero)));
  const SimdFloat4 mid_rot_fu = Xor(
      _mid_rot.xyzw, And(_setup.mask_sign, CmpLt(SplatW(_mid_rot.xyzw), zero)));

  if (_job.weight < 1.f) {
    // NLerp start and mid joint rotations.
    const SimdFloat4 identity = simd_float4::w_axis();
    const SimdFloat4 simd_weight = Max(zero, simd_float4::Load1(_job.weight));

    // Lerp
    const SimdFloat4 start_lerp = Lerp(identity, start_rot_fu, simd_weight);
    const SimdFloat4 mid_lerp = Lerp(identity, mid_rot_fu, simd_weight);

    // Normalize
    const SimdFloat4 rsqrts =
        RSqrtEstNR(SetY(Length4Sqr(start_lerp), Length4Sqr(mid_lerp)));
    _job.start_joint_correction->xyzw = start_lerp * SplatX(rsqrts);
    _job.mid_joint_correction->xyzw = mid_lerp * SplatY(rsqrts);
  } else {
    // Quatenions don't need interpolation
    _job.start_joint_correction->xyzw = start_rot_fu;
    _job.mid_joint_correction->xyzw = mid_rot_fu;
  }
}
}  // namespace

bool IKTwoBoneJob::Run() const {
  if (!Validate()) {
    return false;
  }

  // Early out if weight is 0.
  if (weight <= 0.f) {
    // No correction.
    *start_joint_correction = *mid_joint_correction =
        SimdQuaternion::identity();
    // Target isn't reached.
    if (reached) {
      *reached = false;
    }
    return true;
  }

  // Prepares constant ik data.
  const IKConstantSetup setup(*this);

  // Finds soften target position.
  SimdFloat4 start_target_ss;
  SimdFloat4 start_target_ss_len2;
  const bool lreached =
      SoftenTarget(*this, setup, &start_target_ss, &start_target_ss_len2);
  if (reached) {
    *reached = lreached && weight >= 1.f;
  }

  // Calculate mid_rot_local quaternion which solves for the mid_ss joint
  // rotation.
  const SimdQuaternion mid_rot_ms =
      ComputeMidJoint(*this, setup, start_target_ss_len2);

  // Calculates end_to_target_rot_ss quaternion which solves for effector
  // rotating onto the target.
  const SimdQuaternion start_rot_ss = ComputeStartJoint(
      *this, setup, mid_rot_ms, start_target_ss, start_target_ss_len2);

  // Finally apply weight and output quaternions.
  WeightOutput(*this, setup, start_rot_ss, mid_rot_ms);

  return true;
}
}  // namespace animation
}  // namespace ozz

// Including local_to_model_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/local_to_model_job.h"

#include <cassert>

#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/simd_math.h"
#include "ozz/base/maths/soa_float4x4.h"
#include "ozz/base/maths/soa_transform.h"

#include "ozz/animation/runtime/skeleton.h"

namespace ozz {
namespace animation {

LocalToModelJob::LocalToModelJob()
    : skeleton(nullptr),
      root(nullptr),
      from(Skeleton::kNoParent),
      to(Skeleton::kMaxJoints),
      from_excluded(false) {}

bool LocalToModelJob::Validate() const {
  // Don't need any early out, as jobs are valid in most of the performance
  // critical cases.
  // Tests are written in multiple lines in order to avoid branches.
  bool valid = true;

  // Test for nullptr begin pointers.
  if (!skeleton) {
    return false;
  }

  const size_t num_joints = static_cast<size_t>(skeleton->num_joints());
  const size_t num_soa_joints = (num_joints + 3) / 4;

  // Test input and output ranges, implicitly tests for nullptr end pointers.
  valid &= input.size() >= num_soa_joints;
  valid &= output.size() >= num_joints;

  return valid;
}

bool LocalToModelJob::Run() const {
  if (!Validate()) {
    return false;
  }

  const span<const int16_t>& parents = skeleton->joint_parents();

  // Initializes an identity matrix that will be used to compute roots model
  // matrices without requiring a branch.
  const math::Float4x4 identity = math::Float4x4::identity();
  const math::Float4x4* root_matrix = (root == nullptr) ? &identity : root;

  // Applies hierarchical transformation.
  // Loop ends after "to".
  const int end = math::Min(to + 1, skeleton->num_joints());
  // Begins iteration from "from", or the next joint if "from" is excluded.
  // Process next joint if end is not reach. parents[begin] >= from is true as
  // long as "begin" is a child of "from".
  for (int i = math::Max(from + from_excluded, 0),
           process = i < end && (!from_excluded || parents[i] >= from);
       process;) {
    // Builds soa matrices from soa transforms.
    const math::SoaTransform& transform = input[i / 4];
    const math::SoaFloat4x4 local_soa_matrices = math::SoaFloat4x4::FromAffine(
        transform.translation, transform.rotation, transform.scale);

    // Converts to aos matrices.
    math::Float4x4 local_aos_matrices[4];
    math::Transpose16x16(&local_soa_matrices.cols[0].x,
                         local_aos_matrices->cols);

    // parents[i] >= from is true as long as "i" is a child of "from".
    for (const int soa_end = (i + 4) & ~3; i < soa_end && process;
         ++i, process = i < end && parents[i] >= from) {
      const int parent = parents[i];
      const math::Float4x4* parent_matrix =
          parent == Skeleton::kNoParent ? root_matrix : &output[parent];
      output[i] = *parent_matrix * local_aos_matrices[i & 3];
    }
  }
  return true;
}
}  // namespace animation
}  // namespace ozz

// Including sampling_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/sampling_job.h"

#include <algorithm>
#include <cassert>
#include <limits>

#include "ozz/animation/runtime/animation.h"
#include "ozz/base/encode/group_varint.h"
#include "ozz/base/maths/math_constant.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/soa_transform.h"
#include "ozz/base/memory/allocator.h"

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#include "ozz/animation/runtime/export.h"
#include "ozz/base/platform.h"

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {
namespace internal {

// Offset to previous keyframes are stored on uint16_t.
enum Constants { kMaxPreviousOffset = (1 << 16) - 1 };

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time ratio and it's track index. This is
// required as key frames are not sorted per track, but sorted by ratio to favor
// cache coherency. Key frame values are compressed, according on their type.
// Decompression is efficient because it's done on SoA data and cached during
// sampling.

// Defines the float3 key frame type, used for translations and scales.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct OZZ_ANIMATION_DLL Float3Key {
  uint16_t values[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [-1:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
struct QuaternionKey {
  // 2b for the largest component index of the quaternion.
  // 1b for the sign of the largest component. 1 for negative.
  // 15b for each component
  uint16_t values[3];

  // Quantization scale, depends on number of bits.
  static constexpr int kBits = 15;
  static constexpr int kiScale = (1 << kBits) - 1;
  static constexpr float kfScale = 1.f * kiScale;
};

// Endianness independent load and store
inline void pack(int _largest, int _sign, const int _cpnt[3],
                 QuaternionKey* _key) {
  const uint64_t packed =
      (_largest & 0x3) | ((_sign & 0x1) << 2) | (_cpnt[0] & 0x7fff) << 3 |
      uint64_t(_cpnt[1] & 0x7fff) << 18 | (uint64_t(_cpnt[2]) & 0x7fff) << 33;
  _key->values[0] = packed & 0xffff;
  _key->values[1] = (packed >> 16) & 0xffff;
  _key->values[2] = (packed >> 32) & 0xffff;
}

inline void unpack(const QuaternionKey& _key, int& _biggest, int& _sign,
                   int _cpnt[3]) {
  const uint32_t packed = uint32_t(_key.values[0]) >> 3 |
                          uint32_t(_key.values[1]) << 13 |
                          uint32_t(_key.values[2]) << 29;
  _biggest = _key.values[0] & 0x3;
  _sign = (_key.values[0] >> 2) & 0x1;
  _cpnt[0] = packed & 0x7fff;
  _cpnt[1] = (packed >> 15) & 0x7fff;
  _cpnt[2] = _key.values[2] >> 1;
}

}  // namespace internal
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {

namespace internal {
struct InterpSoaFloat3 {
  math::SimdFloat4 ratio[2];
  math::SoaFloat3 value[2];
};
struct InterpSoaQuaternion {
  math::SimdFloat4 ratio[2];
  math::SoaQuaternion value[2];
};
}  // namespace internal

bool SamplingJob::Validate() const {
  // Don't need any early out, as jobs are valid in most of the performance
  // critical cases.
  // Tests are written in multiple lines in order to avoid branches.
  bool valid = true;

  // Test for nullptr pointers.
  if (!animation || !context) {
    return false;
  }
  valid &= !output.empty();

  const int num_soa_tracks = animation->num_soa_tracks();

  // Tests context size.
  valid &= context->max_soa_tracks() >= num_soa_tracks;

  return valid;
}

namespace {
inline uint32_t TrackForward(const ozz::span<const uint32_t> _cache,
                             const ozz::span<const uint16_t>& _previouses,
                             uint32_t _key, uint32_t _last_track,
                             uint32_t _num_tracks) {
  assert(_key < _previouses.size());
  assert(_last_track >= 0 && _last_track < _num_tracks);

  const uint32_t target = _key - _previouses[_key];
  for (uint32_t entry = _last_track; entry < _num_tracks; ++entry) {
    if (_cache[entry] == target) {
      return entry;
    }
  }
  for (uint32_t entry = 0;; ++entry) {
    if (_cache[entry] == target) {
      return entry;
    }
    assert(entry < _last_track && "Previous track should be in cache");
  }
}

inline uint32_t TrackBackward(const ozz::span<const uint32_t> _cache,
                              uint32_t _target, uint32_t _last_track,
                              uint32_t _num_tracks) {
  assert(_last_track >= 0 && _last_track < _num_tracks);

  for (uint32_t entry = _last_track;; --entry) {
    if (_cache[entry] == _target) {
      return entry;
    }
    if (entry == 0) {
      break;
    }
  }
  for (uint32_t entry = _num_tracks - 1;; --entry) {
    if (_cache[entry] == _target) {
      return entry;
    }
    assert(entry > _last_track && "Previous track should be in cache");
  }
}

inline float KeyRatio(const ozz::span<const float>& _timepoints,
                      const ozz::span<const byte>& _ratios, size_t _at) {
  if (_timepoints.size() <= std::numeric_limits<uint8_t>::max()) {
    return _timepoints[reinterpret_span<const uint8_t>(_ratios)[_at]];
  } else {
    return _timepoints[reinterpret_span<const uint16_t>(_ratios)[_at]];
  }
}

inline ozz::math::SimdFloat4 KeysRatio(
    const ozz::span<const float>& _timepoints,
    const ozz::span<const byte>& _ratios,
    const ozz::span<const uint32_t> _ats) {
  uint16_t index[4];
  if (_timepoints.size() <= std::numeric_limits<uint8_t>::max()) {
    const auto& ratios = reinterpret_span<const uint8_t>(_ratios);
    index[0] = ratios[_ats[0]];
    index[1] = ratios[_ats[1]];
    index[2] = ratios[_ats[2]];
    index[3] = ratios[_ats[3]];
  } else {
    const auto& ratios = reinterpret_span<const uint16_t>(_ratios);
    index[0] = ratios[_ats[0]];
    index[1] = ratios[_ats[1]];
    index[2] = ratios[_ats[2]];
    index[3] = ratios[_ats[3]];
  }
  return ozz::math::simd_float4::Load(
      _timepoints[index[0]], _timepoints[index[1]], _timepoints[index[2]],
      _timepoints[index[3]]);
}

inline uint32_t InitializeCache(const Animation::KeyframesCtrlConst& _ctrl,
                                size_t _iframe,
                                const ozz::span<uint32_t>& _entries) {
  if (_iframe > 0) {
    // Initializes cache entries from a compressed cache iframe.
    size_t iframe = (_iframe - 1) * 2;
    const size_t offset = _ctrl.iframe_desc[iframe];
    ozz::DecodeGV4Stream(_ctrl.iframe_entries.subspan(
                             offset, _ctrl.iframe_entries.size() - offset),
                         _entries);

    // Find "next" keyframe, aka the one after the last cached one.
    return _ctrl.iframe_desc[iframe + 1] + 1;
  } else {
    // Initializes cache entries with the first 2nd sets of key frames. The
    // sorting algorithm ensures that the first 2 key frames of a track are
    // consecutive.
    const uint32_t num_tracks = static_cast<uint32_t>(_entries.size());
    for (uint32_t i = 0; i < num_tracks; ++i) {
      _entries[i] = i + num_tracks;
    }

    // Next is set to the next unprocessed keyframe
    return num_tracks * 2;
  }
}

// Outdates all entries. It's important to only flag valid soa entries as this
// is the exit condition of other algorithms.
inline void OutdateCache(const ozz::span<byte>& _outdated,
                         size_t _num_soa_tracks) {
  const size_t num_outdated_flags = (_num_soa_tracks + 7) / 8;
  size_t i = 0;
  for (; i < num_outdated_flags - 1; ++i) {
    _outdated[i] = 0xff;
  }
  _outdated[i] = 0xff >> (num_outdated_flags * 8 - _num_soa_tracks);
}

// Loops through the sorted key frames and update cache structure.
void UpdateCache(float _ratio, float _previous_ratio, size_t _num_soa_tracks,
                 const ozz::span<const float>& _timepoints,
                 const Animation::KeyframesCtrlConst& _ctrl,
                 SamplingJob::Context::Cache& _cache) {
  assert(_num_soa_tracks > 0);
  const uint32_t num_tracks = static_cast<uint32_t>(_num_soa_tracks * 4);
  assert(_ctrl.previouses.begin() + num_tracks * 2 <= _ctrl.previouses.end());
  const uint32_t num_keys = static_cast<uint32_t>(_ctrl.previouses.size());

  uint32_t next = _cache.next;
  assert(next == 0 || (next >= num_tracks * 2 && next <= num_keys));

  // Initialize cache if needed.
  const float delta = _ratio - _previous_ratio;
  if (next == 0 || std::abs(delta) > _ctrl.iframe_interval / 2.f) {
    int iframe = -1;
    if (!_ctrl.iframe_desc.empty()) {
      // First time, or fast seeking into animation.
      // Finds the closest iframe to the expected _ratio.
      iframe = static_cast<int>(.5f + _ratio / _ctrl.iframe_interval);
    } else if (next == 0 || delta < 0.f) {
      // This handles the cases:
      // - First time, and no iframe
      // - Time is going backward, seeking toward 0, and no iframe is defined.
      // In this case it can still be valuable to reset cache to animation
      // begining.
      iframe = 0;
    }

    // Seek to defined keyframe
    if (iframe >= 0) {
      next = InitializeCache(_ctrl, iframe, _cache.entries.first(num_tracks));
      assert(next >= num_tracks * 2 && next <= num_keys);

      // Cache was overwritten, all entries must be flagged as outdated.
      OutdateCache(_cache.outdated, _num_soa_tracks);
    }
  }

  // Reading forward.
  // Iterates while the cache is not updated with previous key required for
  // interpolation at _ratio. Thanks to the keyframe sorting, the loop can end
  // as soon as it finds a key greater that _ratio. It will mean that all the
  // keys lower than _ratio have been processed, meaning all cache entries are
  // up to date.
  uint32_t track = 0;
  for (; next < num_keys && KeyRatio(_timepoints, _ctrl.ratios,
                                     next - _ctrl.previouses[next]) <= _ratio;
       ++next) {
    // Finds track index.
    track =
        TrackForward(_cache.entries, _ctrl.previouses, next, track, num_tracks);
    assert(_cache.entries[track] == next - _ctrl.previouses[next] &&
           "Wrong cache entry.");

    // Flag this soa entry as outdated.
    _cache.outdated[track / 32] |= 1 << ((track & 0x1f) / 4);

    // Updates cache.
    _cache.entries[track] = next;
  }

  // Rewinds.
  // Checks if the time of the penultimate key is greater than _ratio, in which
  // case we need to rewind.
  for (; KeyRatio(_timepoints, _ctrl.ratios,
                  (next - 1) - _ctrl.previouses[next - 1]) > _ratio;
       --next) {
    assert(next - 1 >= num_tracks * 2);

    // Finds track index.
    track = TrackBackward(_cache.entries, next - 1, track, num_tracks);

    // Flag this soa entry as outdated.
    _cache.outdated[track / 32] |= 1 << ((track & 0x1f) / 4);

    // Updates cache.
    assert(_cache.entries[track] == next - 1);
    const uint32_t previous = _ctrl.previouses[_cache.entries[track]];
    assert(_cache.entries[track] >= previous + num_tracks);
    _cache.entries[track] -= previous;
  }

  // Updates next output.
  assert(next >= num_tracks * 2 && next <= num_keys);
  _cache.next = next;
}

template <typename _CompressedKey, typename _DecompressedKey,
          typename _Decompress>
inline void Decompress(size_t _num_soa_tracks,
                       const ozz::span<const float>& _timepoints,
                       const Animation::KeyframesCtrlConst& _ctrl,
                       const ozz::span<const _CompressedKey>& _compressed,
                       const SamplingJob::Context::Cache& _cache,
                       const ozz::span<_DecompressedKey>& _decompressed,
                       const _Decompress& _decompress) {
  const size_t num_outdated_flags = (_num_soa_tracks + 7) / 8;
  for (size_t j = 0; j < num_outdated_flags; ++j) {
    byte outdated = _cache.outdated[j];  // Copy outdated flag
    _cache.outdated[j] = 0;  // Reset outdated entries as all will be processed.
    for (size_t i = j * 8; outdated != 0; ++i, outdated >>= 1) {
      if (!(outdated & 1)) {
        continue;
      }

      // Get cache sub part matching this outdated soa entry.
      const auto& rights = _cache.entries.subspan(i * 4, 4);

      // Left side keys can be found from right ones as we know the offset from
      // right to left (_previouses).
      const uint32_t lefts[4] = {rights[0] - _ctrl.previouses[rights[0]],
                                 rights[1] - _ctrl.previouses[rights[1]],
                                 rights[2] - _ctrl.previouses[rights[2]],
                                 rights[3] - _ctrl.previouses[rights[3]]};

      // Decompress left side keyframes and store them in soa structures.
      const _CompressedKey& k00 = _compressed[lefts[0]];
      const _CompressedKey& k10 = _compressed[lefts[1]];
      const _CompressedKey& k20 = _compressed[lefts[2]];
      const _CompressedKey& k30 = _compressed[lefts[3]];
      _decompressed[i].ratio[0] = KeysRatio(_timepoints, _ctrl.ratios, lefts);
      _decompress(k00, k10, k20, k30, &_decompressed[i].value[0]);

      // Decompress right side keyframes and store them in soa structures.
      const _CompressedKey& k01 = _compressed[rights[0]];
      const _CompressedKey& k11 = _compressed[rights[1]];
      const _CompressedKey& k21 = _compressed[rights[2]];
      const _CompressedKey& k31 = _compressed[rights[3]];
      _decompressed[i].ratio[1] = KeysRatio(_timepoints, _ctrl.ratios, rights);
      _decompress(k01, k11, k21, k31, &_decompressed[i].value[1]);
    }
  }
}

inline void DecompressFloat3(const internal::Float3Key& _k0,
                             const internal::Float3Key& _k1,
                             const internal::Float3Key& _k2,
                             const internal::Float3Key& _k3,
                             math::SoaFloat3* _soa_float3) {
  _soa_float3->x = math::HalfToFloat(math::simd_int4::Load(
      _k0.values[0], _k1.values[0], _k2.values[0], _k3.values[0]));
  _soa_float3->y = math::HalfToFloat(math::simd_int4::Load(
      _k0.values[1], _k1.values[1], _k2.values[1], _k3.values[1]));
  _soa_float3->z = math::HalfToFloat(math::simd_int4::Load(
      _k0.values[2], _k1.values[2], _k2.values[2], _k3.values[2]));
}

// Defines a mapping table that defines components assignation in the output
// quaternion.
static constexpr uint8_t kCpntMapping[4][4] = {
    {0, 0, 1, 2}, {0, 0, 1, 2}, {0, 1, 0, 2}, {0, 1, 2, 0}};

inline void DecompressQuaternion(const internal::QuaternionKey& _k0,
                                 const internal::QuaternionKey& _k1,
                                 const internal::QuaternionKey& _k2,
                                 const internal::QuaternionKey& _k3,
                                 math::SoaQuaternion* _quaternion) {
  int largests[4], signs[4], values[4][3];
  internal::unpack(_k0, largests[0], signs[0], values[0]);
  internal::unpack(_k1, largests[1], signs[1], values[1]);
  internal::unpack(_k2, largests[2], signs[2], values[2]);
  internal::unpack(_k3, largests[3], signs[3], values[3]);

  // Selects proper mapping for each key.
  const uint8_t* m0 = kCpntMapping[largests[0]];
  const uint8_t* m1 = kCpntMapping[largests[1]];
  const uint8_t* m2 = kCpntMapping[largests[2]];
  const uint8_t* m3 = kCpntMapping[largests[3]];

  // Prepares an array of input values, according to the mapping required to
  // restore quaternion largest component.
  alignas(16) int cmp_keys[4][4] = {
      {values[0][m0[0]], values[1][m1[0]], values[2][m2[0]], values[3][m3[0]]},
      {values[0][m0[1]], values[1][m1[1]], values[2][m2[1]], values[3][m3[1]]},
      {values[0][m0[2]], values[1][m1[2]], values[2][m2[2]], values[3][m3[2]]},
      {values[0][m0[3]], values[1][m1[3]], values[2][m2[3]], values[3][m3[3]]},
  };

  // Rebuilds quaternion from quantized values.
  const math::SimdFloat4 kScale =
      math::simd_float4::Load1(math::kSqrt2 / internal::QuaternionKey::kfScale);
  const math::SimdFloat4 kOffset = math::simd_float4::Load1(-math::kSqrt2_2);
  math::SimdFloat4 cpnt[4] = {
      kScale * math::simd_float4::FromInt(
                   math::simd_int4::LoadPtr(cmp_keys[0])) +
          kOffset,
      kScale * math::simd_float4::FromInt(
                   math::simd_int4::LoadPtr(cmp_keys[1])) +
          kOffset,
      kScale * math::simd_float4::FromInt(
                   math::simd_int4::LoadPtr(cmp_keys[2])) +
          kOffset,
      kScale * math::simd_float4::FromInt(
                   math::simd_int4::LoadPtr(cmp_keys[3])) +
          kOffset};

  // Zeroed largest components so they're not part of the dot.
  const math::SimdInt4 mask_f000 = math::simd_int4::mask_f000();
  const math::SimdInt4 mask_0f00 = math::simd_int4::mask_0f00();
  const math::SimdInt4 mask_00f0 = math::simd_int4::mask_00f0();
  const math::SimdInt4 mask_000f = math::simd_int4::mask_000f();
  cpnt[largests[0]] = math::AndNot(cpnt[largests[0]], mask_f000);
  cpnt[largests[1]] = math::AndNot(cpnt[largests[1]], mask_0f00);
  cpnt[largests[2]] = math::AndNot(cpnt[largests[2]], mask_00f0);
  cpnt[largests[3]] = math::AndNot(cpnt[largests[3]], mask_000f);

  // Get back length of 4th component. Favors performance over accuracy by using
  // x * RSqrtEst(x) instead of Sqrt(x).
  // ww0 cannot be 0 because we 're recomputing the largest component.
  const math::SimdFloat4 dot = cpnt[0] * cpnt[0] + cpnt[1] * cpnt[1] +
                               cpnt[2] * cpnt[2] + cpnt[3] * cpnt[3];
  // dot cannot be >= 1, because it does not include the largest component.
  const math::SimdFloat4 ww0 = math::simd_float4::one() - dot;
  const math::SimdFloat4 w0 = ww0 * math::RSqrtEst(ww0);

  // Re-applies 4th component's sign.
  const math::SimdInt4 sign = math::ShiftL(
      math::simd_int4::Load(signs[0], signs[1], signs[2], signs[3]), 31);
  const math::SimdFloat4 restored = math::Or(w0, sign);

  // Re-injects the largest component inside the SoA structure.
  // Note that largest component is already 0.
  cpnt[largests[0]] =
      math::Or(cpnt[largests[0]], math::And(restored, mask_f000));
  cpnt[largests[1]] =
      math::Or(cpnt[largests[1]], math::And(restored, mask_0f00));
  cpnt[largests[2]] =
      math::Or(cpnt[largests[2]], math::And(restored, mask_00f0));
  cpnt[largests[3]] =
      math::Or(cpnt[largests[3]], math::And(restored, mask_000f));

  // Stores result.
  _quaternion->x = cpnt[0];
  _quaternion->y = cpnt[1];
  _quaternion->z = cpnt[2];
  _quaternion->w = cpnt[3];
}

void Interpolates(float _anim_ratio, size_t _num_soa_tracks,
                  const span<const internal::InterpSoaFloat3>& _translations,
                  const span<const internal::InterpSoaQuaternion>& _rotations,
                  const span<const internal::InterpSoaFloat3>& _scales,
                  const span<math::SoaTransform>& _output) {
  const math::SimdFloat4 anim_ratio = math::simd_float4::Load1(_anim_ratio);
  for (size_t i = 0; i < _num_soa_tracks; ++i) {
    // Prepares interpolation coefficients.
    const internal::InterpSoaFloat3& t = _translations[i];
    const math::SimdFloat4 t_ratio =
        (anim_ratio - t.ratio[0]) * math::RcpEst(t.ratio[1] - t.ratio[0]);
    const internal::InterpSoaQuaternion& r = _rotations[i];
    const math::SimdFloat4 r_ratio =
        (anim_ratio - r.ratio[0]) * math::RcpEst(r.ratio[1] - r.ratio[0]);
    const internal::InterpSoaFloat3& s = _scales[i];
    const math::SimdFloat4 s_ratio =
        (anim_ratio - s.ratio[0]) * math::RcpEst(s.ratio[1] - s.ratio[0]);

    // Processes interpolations.
    // The lerp of the rotation uses the shortest path, because opposed
    // quaternions were negated during animation build stage (see
    // AnimationBuilder).
    _output[i].translation = Lerp(t.value[0], t.value[1], t_ratio);
    _output[i].rotation = NLerpEst(r.value[0], r.value[1], r_ratio);
    _output[i].scale = Lerp(s.value[0], s.value[1], s_ratio);
  }
}
}  // namespace

SamplingJob::SamplingJob() : ratio(0.f), animation(nullptr), context(nullptr) {}

bool SamplingJob::Run() const {
  if (!Validate()) {
    return false;
  }

  // Checked during validation
  assert(context->max_soa_tracks() >= animation->num_soa_tracks());

  // Early out if animation contains no joint.
  const size_t num_soa_tracks =
      static_cast<size_t>(animation->num_soa_tracks());
  if (num_soa_tracks <= 0) {
    return true;
  }

  // Clamps ratio in range [0,duration].
  const float clamped_ratio = math::Clamp(0.f, ratio, 1.f);

  // Step the context to this potentially new animation and ratio.
  const float previous_ratio = context->Step(*animation, clamped_ratio);

  // Update cache with animation keyframe indexes for t = ratio.
  // Decompresses outdated soa hot values.

  // Translations
  const Animation::KeyframesCtrlConst& translations_ctrl =
      animation->translations_ctrl();
  UpdateCache(clamped_ratio, previous_ratio, num_soa_tracks,
              animation->timepoints(), translations_ctrl,
              context->translations_cache_);
  Decompress(num_soa_tracks, animation->timepoints(), translations_ctrl,
             animation->translations_values(), context->translations_cache_,
             context->translations_, &DecompressFloat3);

  // Rotations
  const Animation::KeyframesCtrlConst& rotations_ctrl =
      animation->rotations_ctrl();
  UpdateCache(clamped_ratio, previous_ratio, num_soa_tracks,
              animation->timepoints(), rotations_ctrl,
              context->rotations_cache_);
  Decompress(num_soa_tracks, animation->timepoints(), rotations_ctrl,
             animation->rotations_values(), context->rotations_cache_,
             context->rotations_, &DecompressQuaternion);

  // Scales
  const Animation::KeyframesCtrlConst& scales_ctrl = animation->scales_ctrl();
  UpdateCache(clamped_ratio, previous_ratio, num_soa_tracks,
              animation->timepoints(), scales_ctrl, context->scales_cache_);
  Decompress(num_soa_tracks, animation->timepoints(), scales_ctrl,
             animation->scales_values(), context->scales_cache_,
             context->scales_, &DecompressFloat3);

  // Only interp as much as we have output for.
  const size_t num_soa_interp_tracks = math::Min(output.size(), num_soa_tracks);

  // Interpolates soa hot data.
  Interpolates(clamped_ratio, num_soa_interp_tracks, context->translations_,
               context->rotations_, context->scales_, output);

  return true;
}

SamplingJob::Context::Context() : max_soa_tracks_(0) { Invalidate(); }

SamplingJob::Context::Context(int _max_tracks) : max_soa_tracks_(0) {
  Resize(_max_tracks);
}

SamplingJob::Context::~Context() {
  // translations interp is the allocation pointer, so this deallocates
  // everything at once.
  memory::default_allocator()->Deallocate(translations_.data());
}

void SamplingJob::Context::Resize(int _max_tracks) {
  using internal::InterpSoaFloat3;
  using internal::InterpSoaQuaternion;

  // Reset existing data.
  Invalidate();
  memory::default_allocator()->Deallocate(translations_.data());

  // Updates maximum supported soa tracks.
  max_soa_tracks_ = (math::Max(0, _max_tracks) + 3) / 4;
  const size_t max_soa_tracks = static_cast<size_t>(max_soa_tracks_);

  // Allocate all context data at once in a single allocation.
  // Alignment is guaranteed because memory is dispatch from the highest
  // alignment requirement (Soa data: SimdFloat4) to the lowest (outdated
  // flag: unsigned char).

  // Computes allocation size.
  const size_t max_tracks = max_soa_tracks * 4;
  const size_t num_outdated = (max_soa_tracks + 7) / 8;
  const size_t size =
      sizeof(InterpSoaFloat3) * max_soa_tracks +
      sizeof(InterpSoaQuaternion) * max_soa_tracks +
      sizeof(InterpSoaFloat3) * max_soa_tracks +
      sizeof(uint32_t) * max_tracks * 3 +  // trans + rot + scale.
      sizeof(uint8_t) * 3 * num_outdated;

  // Allocates all at once.
  memory::Allocator* allocator = memory::default_allocator();
  span<byte> buffer = {
      static_cast<byte*>(allocator->Allocate(size, alignof(InterpSoaFloat3))),
      size};

  // Distributes buffer memory while ensuring proper alignment (serves larger
  // alignment values first).
  static_assert(alignof(InterpSoaFloat3) >= alignof(InterpSoaQuaternion) &&
                    alignof(InterpSoaQuaternion) >= alignof(InterpSoaFloat3) &&
                    alignof(InterpSoaFloat3) >= alignof(uint32_t) &&
                    alignof(uint32_t) >= alignof(byte),
                "Must serve larger alignment values first)");

  translations_ = fill_span<InterpSoaFloat3>(buffer, max_soa_tracks);
  rotations_ = fill_span<InterpSoaQuaternion>(buffer, max_soa_tracks);
  scales_ = fill_span<InterpSoaFloat3>(buffer, max_soa_tracks);

  translations_cache_.entries = fill_span<uint32_t>(buffer, max_tracks);
  rotations_cache_.entries = fill_span<uint32_t>(buffer, max_tracks);
  scales_cache_.entries = fill_span<uint32_t>(buffer, max_tracks);

  translations_cache_.outdated = fill_span<byte>(buffer, num_outdated);
  rotations_cache_.outdated = fill_span<byte>(buffer, num_outdated);
  scales_cache_.outdated = fill_span<byte>(buffer, num_outdated);

  assert(buffer.empty());
}

float SamplingJob::Context::Step(const Animation& _animation, float _ratio) {
  // The cache is invalidated if animation has changed...
  if (animation_ != &_animation) {
    Invalidate();
    animation_ = &_animation;
  }
  const float previous_ratio = ratio_;
  ratio_ = _ratio;
  return previous_ratio;
}

void SamplingJob::Context::Invalidate() {
  animation_ = nullptr;
  ratio_ = 0.f;
  translations_cache_.next = 0;
  rotations_cache_.next = 0;
  scales_cache_.next = 0;
}
}  // namespace animation
}  // namespace ozz

// Including skeleton.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/skeleton.h"

#include <cstring>

#include "ozz/base/io/archive.h"
#include "ozz/base/log.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/soa_math_archive.h"
#include "ozz/base/maths/soa_transform.h"
#include "ozz/base/memory/allocator.h"

namespace ozz {
namespace animation {

Skeleton::Skeleton() {}

Skeleton::Skeleton(Skeleton&& _other) { *this = std::move(_other); }

Skeleton& Skeleton::operator=(Skeleton&& _other) {
  std::swap(joint_rest_poses_, _other.joint_rest_poses_);
  std::swap(joint_parents_, _other.joint_parents_);
  std::swap(joint_names_, _other.joint_names_);

  return *this;
}

Skeleton::~Skeleton() { Deallocate(); }

char* Skeleton::Allocate(size_t _chars_size, size_t _num_joints) {
  // Distributes buffer memory while ensuring proper alignment (serves larger
  // alignment values first).
  static_assert(alignof(math::SoaTransform) >= alignof(char*) &&
                    alignof(char*) >= alignof(int16_t) &&
                    alignof(int16_t) >= alignof(char),
                "Must serve larger alignment values first)");

  assert(joint_rest_poses_.size() == 0 && joint_names_.size() == 0 &&
         joint_parents_.size() == 0);

  // Early out if no joint.
  if (_num_joints == 0) {
    return nullptr;
  }

  // Rest poses have SoA format
  const size_t num_soa_joints = (_num_joints + 3) / 4;
  const size_t joint_rest_poses_size =
      num_soa_joints * sizeof(math::SoaTransform);
  const size_t names_size = _num_joints * sizeof(char*);
  const size_t joint_parents_size = _num_joints * sizeof(int16_t);
  const size_t buffer_size =
      names_size + _chars_size + joint_parents_size + joint_rest_poses_size;

  // Allocates whole buffer.
  span<byte> buffer = {static_cast<byte*>(memory::default_allocator()->Allocate(
                           buffer_size, alignof(math::SoaTransform))),
                       buffer_size};

  // Serves larger alignment values first.
  // Rest pose first, biggest alignment.
  joint_rest_poses_ = fill_span<math::SoaTransform>(buffer, num_soa_joints);

  // Then names array, second biggest alignment.
  joint_names_ = fill_span<char*>(buffer, _num_joints);

  // Parents, third biggest alignment.
  joint_parents_ = fill_span<int16_t>(buffer, _num_joints);

  // Remaning buffer will be used to store joint names.
  assert(buffer.size_bytes() == _chars_size &&
         "Whole buffer should be consumned");
  return reinterpret_cast<char*>(buffer.data());
}

void Skeleton::Deallocate() {
  memory::default_allocator()->Deallocate(
      as_writable_bytes(joint_rest_poses_).data());
  joint_rest_poses_ = {};
  joint_names_ = {};
  joint_parents_ = {};
}

void Skeleton::Save(ozz::io::OArchive& _archive) const {
  const int32_t num_joints = this->num_joints();

  // Early out if skeleton's empty.
  _archive << num_joints;
  if (!num_joints) {
    return;
  }

  // Stores names. They are all concatenated in the same buffer, starting at
  // joint_names_[0].
  size_t chars_count = 0;
  for (int i = 0; i < num_joints; ++i) {
    chars_count += (std::strlen(joint_names_[i]) + 1) * sizeof(char);
  }
  _archive << static_cast<int32_t>(chars_count);
  _archive << ozz::io::MakeArray(joint_names_[0], chars_count);
  _archive << ozz::io::MakeArray(joint_parents_);
  _archive << ozz::io::MakeArray(joint_rest_poses_);
}

void Skeleton::Load(ozz::io::IArchive& _archive, uint32_t _version) {
  // Deallocate skeleton in case it was already used before.
  Deallocate();

  if (_version != 2) {
    log::Err() << "Unsupported Skeleton version " << _version << "."
               << std::endl;
    return;
  }

  int32_t num_joints;
  _archive >> num_joints;

  // Early out if skeleton's empty.
  if (!num_joints) {
    return;
  }

  // Read names.
  int32_t chars_count;
  _archive >> chars_count;

  // Allocates all skeleton data members.
  char* cursor = Allocate(chars_count, num_joints);

  // Reads name's buffer, they are all contiguous in the same buffer.
  _archive >> ozz::io::MakeArray(cursor, chars_count);

  // Fixes up array of pointers.
  for (int i = 0; i < num_joints;
       joint_names_[i] = cursor, cursor += std::strlen(cursor) + 1, ++i) {
  }

  _archive >> ozz::io::MakeArray(joint_parents_);
  _archive >> ozz::io::MakeArray(joint_rest_poses_);
}
}  // namespace animation
}  // namespace ozz

// Including skeleton_utils.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/skeleton_utils.h"

#include <assert.h>

#include <cstring>

#include "ozz/base/maths/soa_transform.h"

namespace ozz {
namespace animation {

int FindJoint(const Skeleton& _skeleton, const char* _name) {
  const auto& names = _skeleton.joint_names();
  for (size_t i = 0; i < names.size(); ++i) {
    if (std::strcmp(names[i], _name) == 0) {
      return static_cast<int>(i);
    }
  }
  return -1;
}

// Unpacks skeleton rest pose stored in soa format by the skeleton.
ozz::math::Transform GetJointLocalRestPose(const Skeleton& _skeleton,
                                           int _joint) {
  assert(_joint >= 0 && _joint < _skeleton.num_joints() &&
         "Joint index out of range.");

  const ozz::math::SoaTransform& soa_transform =
      _skeleton.joint_rest_poses()[_joint / 4];

  // Transpose SoA data to AoS.
  ozz::math::SimdFloat4 translations[4];
  ozz::math::Transpose3x4(&soa_transform.translation.x, translations);
  ozz::math::SimdFloat4 rotations[4];
  ozz::math::Transpose4x4(&soa_transform.rotation.x, rotations);
  ozz::math::SimdFloat4 scales[4];
  ozz::math::Transpose3x4(&soa_transform.scale.x, scales);

  // Stores to the Transform object.
  math::Transform rest_pose;
  const int offset = _joint % 4;
  ozz::math::Store3PtrU(translations[offset], &rest_pose.translation.x);
  ozz::math::StorePtrU(rotations[offset], &rest_pose.rotation.x);
  ozz::math::Store3PtrU(scales[offset], &rest_pose.scale.x);

  return rest_pose;
}
}  // namespace animation
}  // namespace ozz

// Including track.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/track.h"

#include <cassert>

#include "ozz/base/io/archive.h"
#include "ozz/base/log.h"
#include "ozz/base/maths/math_archive.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/memory/allocator.h"

namespace ozz {
namespace animation {

namespace internal {

template <typename _ValueType>
Track<_ValueType>::Track() : name_(nullptr) {}

template <typename _ValueType>
Track<_ValueType>::Track(Track<_ValueType>&& _other) {
  *this = std::move(_other);
}

template <typename _ValueType>
Track<_ValueType>& Track<_ValueType>::operator=(Track<_ValueType>&& _other) {
  std::swap(ratios_, _other.ratios_);
  std::swap(values_, _other.values_);
  std::swap(steps_, _other.steps_);
  std::swap(name_, _other.name_);
  return *this;
}

template <typename _ValueType>
Track<_ValueType>::~Track() {
  Deallocate();
}

template <typename _ValueType>
void Track<_ValueType>::Allocate(size_t _keys_count, size_t _name_len) {
  assert(ratios_.size() == 0 && values_.size() == 0);

  // Distributes buffer memory while ensuring proper alignment (serves larger
  // alignment values first).
  static_assert(alignof(_ValueType) >= alignof(float) &&
                    alignof(float) >= alignof(uint8_t),
                "Must serve larger alignment values first)");

  // Compute overall size and allocate a single buffer for all the data.
  const size_t buffer_size = _keys_count * sizeof(_ValueType) +  // values
                             _keys_count * sizeof(float) +       // ratios
                             (_keys_count + 7) * sizeof(uint8_t) / 8 +  // steps
                             (_name_len > 0 ? _name_len + 1 : 0);
  span<byte> buffer = {static_cast<byte*>(memory::default_allocator()->Allocate(
                           buffer_size, alignof(_ValueType))),
                       buffer_size};

  // Fix up pointers. Serves larger alignment values first.
  values_ = fill_span<_ValueType>(buffer, _keys_count);
  ratios_ = fill_span<float>(buffer, _keys_count);
  steps_ = fill_span<uint8_t>(buffer, (_keys_count + 7) / 8);

  // Let name be nullptr if track has no name. Allows to avoid allocating this
  // buffer in the constructor of empty animations.
  name_ =
      _name_len > 0 ? fill_span<char>(buffer, _name_len + 1).data() : nullptr;

  assert(buffer.empty() && "Whole buffer should be consumned");
}

template <typename _ValueType>
void Track<_ValueType>::Deallocate() {
  // Deallocate everything at once.
  memory::default_allocator()->Deallocate(as_writable_bytes(values_).data());

  values_ = {};
  ratios_ = {};
  steps_ = {};
  name_ = nullptr;
}

template <typename _ValueType>
size_t Track<_ValueType>::size() const {
  const size_t size = sizeof(*this) + values_.size_bytes() +
                      ratios_.size_bytes() + steps_.size_bytes();
  return size;
}

template <typename _ValueType>
void Track<_ValueType>::Save(ozz::io::OArchive& _archive) const {
  uint32_t num_keys = static_cast<uint32_t>(ratios_.size());
  _archive << num_keys;

  const size_t name_len = name_ ? std::strlen(name_) : 0;
  _archive << static_cast<int32_t>(name_len);

  _archive << ozz::io::MakeArray(ratios_);
  _archive << ozz::io::MakeArray(values_);
  _archive << ozz::io::MakeArray(steps_);

  _archive << ozz::io::MakeArray(name_, name_len);
}

template <typename _ValueType>
void Track<_ValueType>::Load(ozz::io::IArchive& _archive, uint32_t _version) {
  // Destroy animation in case it was already used before.
  Deallocate();

  if (_version > 1) {
    log::Err() << "Unsupported Track version " << _version << "." << std::endl;
    return;
  }

  uint32_t num_keys;
  _archive >> num_keys;

  int32_t name_len;
  _archive >> name_len;

  Allocate(num_keys, name_len);

  _archive >> ozz::io::MakeArray(ratios_);
  _archive >> ozz::io::MakeArray(values_);
  _archive >> ozz::io::MakeArray(steps_);

  if (name_) {  // nullptr name_ is supported.
    _archive >> ozz::io::MakeArray(name_, name_len);
    name_[name_len] = 0;
  }
}

// Explicitly instantiate supported tracks.
template class OZZ_ANIMATION_DLL Track<float>;
template class OZZ_ANIMATION_DLL Track<math::Float2>;
template class OZZ_ANIMATION_DLL Track<math::Float3>;
template class OZZ_ANIMATION_DLL Track<math::Float4>;
template class OZZ_ANIMATION_DLL Track<math::Quaternion>;

}  // namespace internal
}  // namespace animation
}  // namespace ozz

// Including track_sampling_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/track_sampling_job.h"
#include "ozz/animation/runtime/track.h"
#include "ozz/base/maths/math_ex.h"

#include <algorithm>
#include <cassert>

namespace ozz {
namespace animation {
namespace internal {

template <typename _Track>
TrackSamplingJob<_Track>::TrackSamplingJob()
    : ratio(0.f), track(nullptr), result(nullptr) {}

template <typename _Track>
bool TrackSamplingJob<_Track>::Validate() const {
  bool success = true;
  success &= result != nullptr;
  success &= track != nullptr;
  return success;
}

template <typename _Track>
bool TrackSamplingJob<_Track>::Run() const {
  if (!Validate()) {
    return false;
  }

  // Clamps ratio in range [0,1].
  const float clamped_ratio = math::Clamp(0.f, ratio, 1.f);

  // Search keyframes to interpolate.
  const span<const float> ratios = track->ratios();
  const span<const ValueType> values = track->values();
  assert(ratios.size() == values.size() &&
         track->steps().size() * 8 >= values.size());

  // Default track returns identity.
  if (ratios.size() == 0) {
    *result = internal::TrackPolicy<ValueType>::identity();
    return true;
  }

  // Search for the first key frame with a ratio value greater than input ratio.
  // Our ratio is between this one and the previous one.
  const float* ptk1 = std::upper_bound(ratios.begin(), ratios.end(), clamped_ratio);

  // Deduce keys indices.
  const size_t id1 = ptk1 - ratios.begin();
  const size_t id0 = id1 - 1;

  const bool id0step = (track->steps()[id0 / 8] & (1 << (id0 & 7))) != 0;
  if (id0step || ptk1 == ratios.end()) {
    *result = values[id0];
  } else {
    // Lerp relevant keys.
    const float tk0 = ratios[id0];
    const float tk1 = ratios[id1];
    assert(clamped_ratio >= tk0 && clamped_ratio < tk1 && tk0 != tk1);
    const float alpha = (clamped_ratio - tk0) / (tk1 - tk0);
    const ValueType& vk0 = values[id0];
    const ValueType& vk1 = values[id1];
    *result = internal::TrackPolicy<ValueType>::Lerp(vk0, vk1, alpha);
  }
  return true;
}

// Explicitly instantiate supported tracks.
template struct TrackSamplingJob<FloatTrack>;
template struct TrackSamplingJob<Float2Track>;
template struct TrackSamplingJob<Float3Track>;
template struct TrackSamplingJob<Float4Track>;
template struct TrackSamplingJob<QuaternionTrack>;
}  // namespace internal
}  // namespace animation
}  // namespace ozz

// Including track_triggering_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) Guillaume Blanc                                              //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/track_triggering_job.h"
#include "ozz/animation/runtime/track.h"

#include <algorithm>
#include <cassert>

namespace ozz {
namespace animation {

TrackTriggeringJob::TrackTriggeringJob()
    : from(0.f), to(0.f), threshold(0.f), track(nullptr), iterator(nullptr) {}

bool TrackTriggeringJob::Validate() const {
  bool valid = true;
  valid &= track != nullptr;
  valid &= iterator != nullptr;
  return valid;
}

bool TrackTriggeringJob::Run() const {
  if (!Validate()) {
    return false;
  }

  // Triggering can only happen in a valid range of ratio.
  if (from == to) {
    *iterator = end();
    return true;
  }

  *iterator = Iterator(this);

  return true;
}

namespace {
inline bool DetectEdge(ptrdiff_t _i0, ptrdiff_t _i1, bool _forward,
                       const TrackTriggeringJob& _job,
                       TrackTriggeringJob::Edge* _edge) {
  const span<const float>& values = _job.track->values();

  const float vk0 = values[_i0];
  const float vk1 = values[_i1];

  bool detected = false;
  if (vk0 <= _job.threshold && vk1 > _job.threshold) {
    // Rising edge
    _edge->rising = _forward;
    detected = true;
  } else if (vk0 > _job.threshold && vk1 <= _job.threshold) {
    // Falling edge
    _edge->rising = !_forward;
    detected = true;
  }

  if (detected) {
    const span<const float>& ratios = _job.track->ratios();
    const span<const uint8_t>& steps = _job.track->steps();

    const bool step = (steps[_i0 / 8] & (1 << (_i0 & 7))) != 0;
    if (step) {
      _edge->ratio = ratios[_i1];
    } else {
      assert(vk0 != vk1);  // Won't divide by 0

      if (_i1 == 0) {
        _edge->ratio = 0.f;
      } else {
        // Finds where the curve crosses threshold value.
        // This is the lerp equation, where we know the result and look for
        // alpha, aka un-lerp.
        const float alpha = (_job.threshold - vk0) / (vk1 - vk0);

        // Remaps to keyframes actual times.
        const float tk0 = ratios[_i0];
        const float tk1 = ratios[_i1];
        _edge->ratio = math::Lerp(tk0, tk1, alpha);
      }
    }
  }
  return detected;
}
}  // namespace

TrackTriggeringJob::Iterator::Iterator(const TrackTriggeringJob* _job)
    : job_(_job) {
  // Outer loop initialization.
  outer_ = floorf(job_->from);

  // Search could start more closely to the "from" ratio, but it's not possible
  // to ensure that floating point precision will not lead to missing a key
  // (when from/to range is far from 0). This is less good in algorithmic
  // complexity, but for consistency of forward and backward triggering, it's
  // better to let iterator ++ implementation filter included and excluded
  // edges.
  inner_ = job_->from < job_->to ? 0 : _job->track->ratios().size() - 1;

  // Evaluates first edge.
  ++*this;
}

const TrackTriggeringJob::Iterator& TrackTriggeringJob::Iterator::operator++() {
  assert(*this != job_->end() && "Can't increment end iterator.");

  const span<const float>& ratios = job_->track->ratios();
  const ptrdiff_t num_keys = ratios.size();

  if (job_->to > job_->from) {
    for (; outer_ < job_->to; outer_ += 1.f) {
      for (; inner_ < num_keys; ++inner_) {
        const ptrdiff_t i0 = inner_ == 0 ? num_keys - 1 : inner_ - 1;
        if (DetectEdge(i0, inner_, true, *job_, &edge_)) {
          edge_.ratio += outer_;  // Convert to global ratio space.
          if (edge_.ratio >= job_->from &&
              (edge_.ratio < job_->to || job_->to >= 1.f + outer_)) {
            ++inner_;
            return *this;  // Yield found edge.
          }
          // Won't find any further edge.
          if (ratios[inner_] + outer_ >= job_->to) {
            break;
          }
        }
      }
      inner_ = 0;  // Ready for next loop.
    }
  } else {
    for (; outer_ + 1.f > job_->to; outer_ -= 1.f) {
      for (; inner_ >= 0; --inner_) {
        const ptrdiff_t i0 = inner_ == 0 ? num_keys - 1 : inner_ - 1;
        if (DetectEdge(i0, inner_, false, *job_, &edge_)) {
          edge_.ratio += outer_;  // Convert to global ratio space.
          if (edge_.ratio >= job_->to &&
              (edge_.ratio < job_->from || job_->from >= 1.f + outer_)) {
            --inner_;
            return *this;  // Yield found edge.
          }
        }
        // Won't find any further edge.
        if (ratios[inner_] + outer_ <= job_->to) {
          break;
        }
      }
      inner_ = ratios.size() - 1;  // Ready for next loop.
    }
  }

  // Set iterator to end position.
  *this = job_->end();

  return *this;
}
}  // namespace animation
}  // namespace ozz

